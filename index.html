<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Art Supply Emporium</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Indie+Flower&family=Patrick+Hand&family=VT323&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Patrick Hand', cursive;
            background-color: #f7e7d8;
            color: #5d4037;
            overflow: hidden; /* Prevent scrollbars */
        }

        canvas {
            border: 2px solid #5d4037;
            background-color: #fcf6e7;
            touch-action: none;
            display: block; /* Removes bottom margin */
            cursor: pointer;
        }

        #pie-clock-canvas {
            background-color: transparent;
            border: none;
        }

        .font-handwritten {
            font-family: 'Indie Flower', cursive;
        }

        .customer-bubble {
            background-color: rgba(255, 255, 255, 0.9);
            border: 2px solid #5d4037;
            box-shadow: 4px 4px 0px 0px #5d4037;
        }

        .btn-style {
            background-color: #5d4037;
            color: #f7e7d8;
            border: 2px solid #5d4037;
            box-shadow: 4px 4px 0px 0px #5d4037;
            transition: all 0.1s;
        }

        .btn-style:active {
            box-shadow: 0px 0px 0px 0px #5d4037;
            transform: translate(4px, 4px);
        }

        .btn-style:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .tooltip {
            visibility: hidden;
            background-color: #5d4037;
            color: #f7e7d8;
            padding: 5px 10px;
            border-radius: 8px;
            position: absolute;
            z-index: 100;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .item-tooltip:hover .tooltip {
            visibility: visible;
        }

        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fcf6e7;
            border: 2px solid #5d4037;
            padding: 2rem;
            z-index: 2000;
            box-shadow: 8px 8px 0px 0px #5d4037;
            text-align: center;
        }

        #phone-panel {
            max-width: 420px; /* Increased width */
            height: 90vh; /* Increased height */
            max-height: 800px;
        }

        .phone-app-screen {
            color: #5d4037;
            background-color: #f7e7d8;
        }

        /* Toggle Switch Styles */
        .toggle-checkbox:checked {
            background-color: #22c55e; /* green-500 */
            border-color: #166534; /* green-800 */
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #f7e7d8;
        }
    </style>
</head>
<body class="p-4 flex flex-col items-center justify-center h-screen">

    <!-- The main container for the game canvas and its overlay UI -->
    <div id="game-container" class="relative w-full flex-grow">
        <!-- The UI that sits on top of the canvas -->
        <div id="game-ui" class="absolute top-4 left-4 z-10 flex items-center space-x-4">
             <div class="p-3 text-xl border-2 border-amber-900 rounded-lg bg-amber-100/80 shadow-md backdrop-blur-sm">
                 $<span id="cash-display">0</span>
             </div>
             <div class="p-3 text-xl border-2 border-amber-900 rounded-lg bg-amber-100/80 shadow-md backdrop-blur-sm">
                 Day: <span id="day-display">1</span>
             </div>
              <div class="p-3 text-xl border-2 border-amber-900 rounded-lg bg-amber-100/80 shadow-md backdrop-blur-sm">
                 Points: <span id="shop-points-display">0</span>
             </div>
             <button id="start-day-btn" class="btn-style px-6 py-3 rounded-lg text-xl hidden">Start Day</button>
             <canvas id="pie-clock-canvas" width="50" height="50"></canvas>
        </div>

        <!-- Canvas for the game -->
        <canvas id="game-canvas" class="rounded-lg shadow-xl w-full h-full"></canvas>

        <!-- Hidden canvas for generating the sprite sheet -->
        <canvas id="spriteSheetCanvas" width="270" height="270" style="display:none;"></canvas>

        <!-- Phone Panel -->
        <div id="phone-panel" class="hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-full p-2 border-4 border-amber-900 rounded-2xl bg-amber-100/95 shadow-xl z-30 backdrop-blur-sm">
             <div id="phone-screen" class="bg-gray-800 rounded-lg h-full flex flex-col overflow-hidden">
                <!-- Phone Header -->
                <div class="flex-shrink-0 flex justify-between items-center pb-2 border-b border-gray-600 px-4 pt-2">
                    <span id="phone-time" class="text-sm font-bold text-gray-300">9:41 AM</span>
                    <div class="w-24 h-5 bg-black rounded-full"></div>
                    <div class="flex items-center space-x-2">
                         <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-gray-300"><path d="M12 20h.01"/><path d="M8.5 16.5a5 5 0 0 1 7 0"/><path d="M2 8.82a15 15 0 0 1 20 0"/></svg>
                         <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="text-gray-300"><path d="M2 2h20v20H2z"/></svg>
                    </div>
                </div>

                <!-- Apps Grid -->
                <div id="phone-apps-grid" class="grid grid-cols-4 gap-x-2 gap-y-4 p-4 flex-grow overflow-y-auto">
                    <!-- App icons will be populated here by JS -->
                </div>

                <!-- Nested App Screens -->
                <div id="phone-app-screens" class="flex-grow overflow-y-auto hidden p-4 space-y-4">
                    <!-- Settings Panel -->
                    <div id="settings-panel" class="phone-app-screen hidden">
                        <h2 class="text-3xl font-handwritten mb-4">Settings</h2>
                        <div class="space-y-4">
                            <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                                <label for="developer-toggle" class="text-lg">Developer Mode</label>
                                <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                                    <input type="checkbox" name="developer-toggle" id="developer-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                    <label for="developer-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                                </div>
                            </div>
                            <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                                <label for="continuous-toggle" class="text-lg">Continuous Day</label>
                                <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                                    <input type="checkbox" name="continuous-toggle" id="continuous-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                    <label for="continuous-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                                </div>
                            </div>
                            <button id="new-game-btn" class="btn-style w-full py-2">Start New Game</button>
                        </div>
                    </div>

                    <!-- Unlocks Panel -->
                    <div id="unlocks-panel" class="phone-app-screen hidden">
                        <h2 class="text-3xl font-handwritten mb-4">Unlocks</h2>
                        <div class="space-y-4">
                            <div>
                                <h3 class="text-xl font-handwritten border-b-2 border-amber-800/30 mb-2">Employees</h3>
                                <div id="unlocks-employees" class="space-y-2"></div>
                            </div>
                            <div>
                                <h3 class="text-xl font-handwritten border-b-2 border-amber-800/30 mb-2">Shelves</h3>
                                <div id="unlocks-shelves" class="space-y-2"></div>
                            </div>
                            <div>
                                <h3 class="text-xl font-handwritten border-b-2 border-amber-800/30 mb-2">Storage</h3>
                                <div id="unlocks-storage" class="space-y-2"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Restock Panel -->
                    <div id="restock-panel" class="phone-app-screen hidden">
                        <h2 class="text-3xl font-handwritten mb-4">Order Supplies</h2>
                        <div id="restock-grid" class="space-y-2"></div>
                        <div class="mt-4 pt-2 border-t-2 border-amber-800/30 flex justify-between items-center">
                            <span class="text-xl">Total: $<span id="restock-total">0.00</span></span>
                            <button id="place-order-btn" class="btn-style px-4 py-2">Place Order</button>
                        </div>
                    </div>

                    <!-- Favorites Panel -->
                    <div id="favorites-panel" class="phone-app-screen hidden">
                        <h2 class="text-3xl font-handwritten mb-4">Favorites</h2>
                        <div id="favorites-grid" class="space-y-2"></div>
                         <div class="mt-4 pt-2 border-t-2 border-amber-800/30 flex justify-between items-center">
                            <span class="text-xl">Total: $<span id="favorites-total">0.00</span></span>
                            <button id="place-favorites-order-btn" class="btn-style px-4 py-2">Order All</button>
                        </div>
                    </div>

                    <!-- Basket Panel -->
                    <div id="basket-panel" class="phone-app-screen hidden">
                        <h2 class="text-3xl font-handwritten mb-4">Your Basket</h2>
                        <div id="basket-grid" class="space-y-2"></div>
                    </div>

                    <!-- Shelf Assignment Panel -->
                    <div id="shelf-assignment-panel" class="phone-app-screen hidden">
                        <h2 id="shelf-assignment-title" class="text-3xl font-handwritten mb-4">Shelf Assignments</h2>
                        <div id="shelf-assignment-grid" class="grid grid-cols-2 gap-2"></div>
                    </div>

                    <!-- Assignment Panel -->
                    <div id="assignment-panel" class="phone-app-screen hidden">
                        <h2 id="assignment-title" class="text-2xl font-handwritten mb-4">Assign Item</h2>
                        <div id="assignment-grid" class="grid grid-cols-2 gap-2"></div>
                    </div>

                    <!-- Employees Panel -->
                    <div id="employees-panel" class="phone-app-screen hidden">
                        <h2 class="text-3xl font-handwritten mb-4">Manage Employees</h2>
                        <div id="employee-list" class="space-y-2"></div>
                    </div>

                    <!-- Customers Panel -->
                    <div id="customers-panel" class="phone-app-screen hidden">
                        <h2 class="text-3xl font-handwritten mb-4">Customers</h2>
                        <div class="flex border-b-2 border-amber-800/30 mb-2">
                            <button id="in-store-customers-btn" class="flex-1 p-2 bg-amber-800/20 rounded-t-md">In Store</button>
                            <button id="all-customers-btn" class="flex-1 p-2 bg-amber-800/20 rounded-t-md bg-opacity-50">All</button>
                        </div>
                        <div id="in-store-customer-list" class="space-y-2"></div>
                        <div id="all-customer-list" class="hidden flex-col space-y-2"></div>
                    </div>

                     <!-- Reports Panel -->
                    <div id="reports-panel" class="phone-app-screen hidden">
                        <h2 class="text-3xl font-handwritten mb-4">Daily Reports</h2>
                        <p>This feature is coming soon!</p>
                    </div>
                </div>


                <!-- Phone Footer / Close Button -->
                <div class="flex-shrink-0 pt-4 mt-auto flex justify-center items-center space-x-12">
                    <button id="phone-back-btn" class="text-gray-400 hover:text-white transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5"/><path d="m12 19-7-7 7-7"/></svg>
                    </button>
                     <button id="close-phone" class="w-24 h-1.5 bg-gray-500 rounded-full hover:bg-gray-400 transition-colors"></button>
                </div>
            </div>
        </div>
    </div>

    <!-- Message Box -->
    <div id="message-box" class="hidden rounded-lg">
        <p id="message-text" class="text-lg"></p>
        <button id="message-ok-btn" class="btn-style mt-4 px-4 py-2 rounded-lg">OK</button>
    </div>

    <!-- End of Day Report Panel -->
    <div id="end-of-day-panel" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-2000">
        <div class="bg-amber-100 w-full max-w-2xl p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900">
            <h2 class="text-3xl font-handwritten text-center mb-4">End of Day Report</h2>
            <div class="grid grid-cols-2 gap-6">
                <!-- Left Side: Summary -->
                <div>
                    <h3 class="text-xl font-handwritten border-b-2 border-amber-800/30 mb-2">Summary</h3>
                    <div class="space-y-2 text-lg">
                        <p>Day Ended: <span id="report-day" class="font-bold"></span></p>
                        <p>Gross Sales: <span id="report-sales" class="font-bold"></span></p>
                        <p>Daily Expenses: <span id="report-expenses" class="font-bold"></span></p>
                        <p class="border-t border-amber-800/30 pt-2">Net Profit: <span id="report-profit" class="font-bold"></span></p>
                    </div>
                </div>
                <!-- Right Side: Sales Details -->
                <div>
                    <h3 class="text-xl font-handwritten border-b-2 border-amber-800/30 mb-2">Customer Details</h3>
                    <div id="sales-report-list" class="h-64 overflow-y-auto space-y-3 p-2 bg-white/30 rounded-md border">
                        <!-- Report items will be populated here -->
                    </div>
                    <div id="report-summary-extra" class="mt-2 text-sm">
                        <!-- Extra summary stats will be populated here -->
                    </div>
                </div>
            </div>
            <div class="text-center mt-6">
                <button id="next-day-report-btn" class="btn-style px-8 py-3 text-xl">Start Next Day</button>
            </div>
        </div>
    </div>


    <script>
        function showMessage(text, callback) {
            const msgBox = document.getElementById('message-box');
            const msgText = document.getElementById('message-text');
            const msgBtn = document.getElementById('message-ok-btn');

            msgText.textContent = text;
            msgBox.classList.remove('hidden');

            const clickHandler = () => {
                msgBox.classList.add('hidden');
                if (callback) callback();
                msgBtn.removeEventListener('click', clickHandler);
            };
            msgBtn.addEventListener('click', clickHandler);
        }

        const customerTypes = {
            'artist': {
                name: 'Artist',
                storageLabel: 'Drawing',
                storageIndex: 0,
                spriteType: 'student'
            },
            'painter': {
                name: 'Painter',
                storageLabel: 'Painting',
                storageIndex: 1,
                spriteType: 'painter'
            },
            'hobbyist': {
                name: 'Hobbyist',
                storageLabel: 'Models',
                storageIndex: 2,
                spriteType: 'modelMaker'
            },
            'woodworker': {
                name: 'Woodworker',
                storageLabel: 'Woodworking',
                storageIndex: 3,
                spriteType: 'woodworker'
            },
            'sculptor': {
                name: 'Sculptor',
                storageLabel: 'Sculpture',
                storageIndex: 4,
                spriteType: 'sculptor'
            },
            'architect': {
                name: 'Architect',
                storageLabel: 'Architectural',
                storageIndex: 5,
                spriteType: 'architect'
            }
        };

        let customerProfiles = {
            'artist': {
                "Leo": { "request": "I need some basic supplies for my life drawing class.", "requestedItems": ["Pencil", "Sketchbook"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Kara": { "request": "I want to try some charcoal drawings. Got any?", "requestedItems": ["Charcoal"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Benny": { "request": "My markers have all dried out! I need a new set.", "requestedItems": ["Markers"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Vince": { "request": "I'm teaching a class, I need a bulk order of sketchbooks.", "requestedItems": ["Sketchbook", "Sketchbook", "Sketchbook"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Arturo": { "request": "Just a pencil for now, maybe a sketchbook if I feel inspired.", "requestedItems": ["Pencil"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Penelope": { "request": "I need a good set of colored markers for a commission piece.", "requestedItems": ["Markers"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Chuck": { "request": "Do you have any fine-tipped charcoal pencils?", "requestedItems": ["Charcoal", "Pencil"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false }
            },
            'painter': {
                "Frida": { "request": "I'm starting a new self-portrait. I'll need acrylics and a canvas.", "requestedItems": ["Acrylics", "Canvas"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Claude": { "request": "Just need some water colors for some light studies.", "requestedItems": ["Water Color"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Georgia": { "request": "I'm working on a large piece. I need oil paints.", "requestedItems": ["Oils", "Canvas"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Bob": { "request": "Time to paint some happy little trees. Need some oils.", "requestedItems": ["Oils"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Rembrandt": { "request": "I require the finest acrylics for my next masterpiece.", "requestedItems": ["Acrylics"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Sonia": { "request": "A small canvas and some water colors, please.", "requestedItems": ["Canvas", "Water Color"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "JMW": { "request": "I'm feeling dramatic. Give me your most vibrant oils and a large canvas.", "requestedItems": ["Oils", "Canvas"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false }
            },
            'hobbyist': {
                "Wally": { "request": "I'm building a new model ship. I need glue and some razors for the small parts.", "requestedItems": ["Glue", "Razors"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Gundam Guy": { "request": "I need to paint my latest creation. Got any mini paints?", "requestedItems": ["Mini Paints"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Tanya": { "request": "I'm ready to start a new project. A model kit, please!", "requestedItems": ["Model Kits"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Duncan": { "request": "Two thin coats of mini paints are all I need.", "requestedItems": ["Mini Paints"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Rick": { "request": "I need razors to... uh... 'customize' my models. Yeah, that's it.", "requestedItems": ["Razors"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Mini Martha": { "request": "A little glue can fix anything!", "requestedItems": ["Glue"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Captain Kit": { "request": "I'm on the hunt for a new model kit to assemble.", "requestedItems": ["Model Kits", "Glue"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false }
            },
            'woodworker': {
                "Ron": { "request": "I need to finish a chair. Some sanding paper and stainer should do it.", "requestedItems": ["Sanding Paper", "Stainer"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Tammy": { "request": "I'm just starting out. Do you have any wood scraps I can practice on?", "requestedItems": ["Wood Scraps"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "April": { "request": "I'm building a large table and need some lumber.", "requestedItems": ["Lumber"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Nick": { "request": "I need some quality lumber for a custom piece.", "requestedItems": ["Lumber"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Pat": { "request": "Just some sanding paper to smooth things over.", "requestedItems": ["Sanding Paper"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Woody": { "request": "Got any interesting wood scraps? I like a challenge.", "requestedItems": ["Wood Scraps"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Cheryl": { "request": "I'm staining a deck. I'll need a lot of stainer.", "requestedItems": ["Stainer", "Stainer"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false }
            },
            'sculptor': {
                "Michelangelo": { "request": "I have a vision! I require clay to bring it to life.", "requestedItems": ["Clay"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Auguste": { "request": "I need to paint a ceramic piece. Do you have pottery paints?", "requestedItems": ["Pottery Paints"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Donatello": { "request": "I am ready to work with a harder medium. A block of stone, please.", "requestedItems": ["Stone", "Clay"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Henry": { "request": "I'm thinking... bigger. A block of marble.", "requestedItems": ["Marble"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Camille": { "request": "I need clay, and perhaps some pottery paints for the details.", "requestedItems": ["Clay", "Pottery Paints"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Constantin": { "request": "Just a simple block of stone today.", "requestedItems": ["Stone"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Barbara": { "request": "I'm making a set of mugs. Clay and pottery paints, please.", "requestedItems": ["Clay", "Pottery Paints", "Clay"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false }
            },
            'architect': {
                "Frank": { "request": "I'm drafting a new building. I need vellum and some fresh pencil lead.", "requestedItems": ["Vellum", "Pencil Lead"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Zaha": { "request": "I need to make a model for a presentation. Do you sell tiny trees?", "requestedItems": ["Tiny Trees"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Chris": { "request": "I'm working on some final designs and need some high-quality markers.", "requestedItems": ["Fancy Markers", "Vellum"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Renzo": { "request": "I've run out of pencil lead again.", "requestedItems": ["Pencil Lead"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Tadao": { "request": "I require vellum for some concrete plans.", "requestedItems": ["Vellum"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Maya": { "request": "I'm designing a park. I'll take all the tiny trees you have.", "requestedItems": ["Tiny Trees", "Tiny Trees"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false },
                "Norman": { "request": "A set of your fanciest markers, if you please.", "requestedItems": ["Fancy Markers"], "patience": 100, "visitedToday": false, "toolsOwned": [], "isStarred": false }
            }
        };

        async function generateCustomerRequest() {
            const availableTypeKeys = ['artist'];
            unlocks.storage.forEach((isUnlocked, index) => {
                if (isUnlocked) {
                    const typeKey = Object.keys(customerTypes).find(key => customerTypes[key].storageIndex === index);
                    if (typeKey && !availableTypeKeys.includes(typeKey)) {
                        availableTypeKeys.push(typeKey);
                    }
                }
            });

            const unlockedItems = new Set(storageCells[0].allowedItems); // Artists are always available
            unlocks.storage.forEach((isUnlocked, index) => {
                if (isUnlocked) {
                    storageCells[index].allowedItems.forEach(item => unlockedItems.add(item));
                }
            });


            if (availableTypeKeys.length === 0) {
                console.warn("No customer types available to spawn.");
                return null;
            }

            for (let i = 0; i < 20; i++) { // Retry loop
                const chosenTypeKey = availableTypeKeys[Math.floor(Math.random() * availableTypeKeys.length)];
                const customersForType = customerProfiles[chosenTypeKey];

                const availableCustomers = Object.keys(customersForType).filter(name => !customersForType[name].visitedToday);

                if (availableCustomers.length === 0) {
                    continue;
                }

                const chosenCustomerName = availableCustomers[Math.floor(Math.random() * availableCustomers.length)];
                const customerData = { ...customersForType[chosenCustomerName] };

                const validRequestedItems = customerData.requestedItems.filter(item => unlockedItems.has(item));

                if (validRequestedItems.length > 0) {
                    customerData.requestedItems = validRequestedItems;
                    customersForType[chosenCustomerName].visitedToday = true;

                    return {
                        name: chosenCustomerName,
                        ...customerData,
                        customerType: chosenTypeKey
                    };
                }
            }

            return null;
        }

        let cash = 100;
        let day = 1;
        let shopPoints = 0;
        let itemPopularity = {};
        let customers = [];
        let customerDemand = {};
        let canvas, ctx, pieClockCanvas, pieClockCtx;
        let lastTimestamp = 0;
        let running = true;
        let dayStarted = false;
        let developerMode = false;
        let continuousMode = false;
        let isMandatoryBreak = false;
        let midDayBreakTriggered = false;
        let starredItems = [];

        const OPENING_DURATION = 60000; // 1 minute
        const OPEN_DURATION = 180000; // 3 minutes
        const CLOSING_DURATION = 60000; // 1 minute
        const DAY_DURATION = OPENING_DURATION + OPEN_DURATION + CLOSING_DURATION; // Total 5 minutes
        let dayTimer = DAY_DURATION;
        let dayPhase = 'pre-open'; // 'pre-open', 'opening', 'open', 'closing'
        let zone1PointTimer = 0;

        const CUSTOMER_SPAWN_INTERVAL = 8000;
        let timeSinceLastCustomer = 0;
        let floatingTexts = [];
        let clipboardUpdateTimer = 0;
        const CLIPBOARD_UPDATE_INTERVAL = 250; // ms
        let dailySalesReport = [];

        // Camera and zoom variables
        let cameraX = 0;
        let cameraY = 0;
        let targetCameraX = 0;
        let cameraState = 'store'; // 'store' or 'office'
        let officeWidth;
        let worldWidth;


        const desk = { x: 0, y: 0, width: 0, height: 30 };
        const loadingDock = { x: 0, y: 0, width: 0, height: 50 };
        const cashierCounter = { x: 0, y: 0, w: 40, h: 120 };
        const managersOffice = { x: 0, y: 0, w: 100, h: 100 };
        const officeZone1 = { x: 0, y: 0, w: 0, h: 0 };
        const officeZone2 = { x: 0, y: 0, w: 0, h: 0 };
        const officeZone3 = { x: 0, y: 0, w: 0, h: 0 };
        const cashRegister = { x: 0, y: 0, width: 60, height: 50 };
        const clipboard = { x: 0, y: 0, width: 50, height: 60 };
        const shoppingBasket = { x: 0, y: 0, width: 60, height: 50 };
        const lockIcon = { x: 0, y: 0, width: 50, height: 50 };
        const phoneIcon = { x: 0, y: 0, width: 50, height: 50 };
        let storageCells = [];
        let shelves = [];
        const MAX_BASKET_SIZE = 5;
        const MAX_SHELF_STACK = 10;
        const STOCKER_BASKET_SIZE = 6 * MAX_SHELF_STACK;
        const LOADER_BASKET_SIZE = 10;
        const MAX_PACKAGE_SIZE = 20;
        const PACKAGE_WIDTH = 60;
        const PACKAGE_HEIGHT = 50;
        let loadingDockPackages = [];

        let unlocks = {
            employees: { cashier: false, stocker: false, loader: false, manager: false, salesperson: false },
            shelves: [true, false, false, false, false, false],
            storage: [false, false, false, false, false, false]
        };

        const unlockCosts = {
            employees: { cashier: 10, stocker: 15, loader: 20, manager: 50, salesperson: 30 },
            shelves: [null, 5, 10, 20, 40, 80], // index 0 is free
            storage: [10, 20, 30, 40, 50, 60]
        };

        const player = {
            x: 100, y: 300, width: 50, height: 50, speed: 250,
            targetX: null,
            targetY: null,
            currentFrame: 0, frameWidth: 90, frameHeight: 90,
            animationSpeed: 150, lastFrameTime: 0,
            state: 'idle', facing: 'right',
            basket: []
        };

        const stocker = {
            x: 300, y: 300, width: 50, height: 50, speed: 180,
            currentFrame: 0, frameWidth: 90, frameHeight: 90,
            animationSpeed: 150, lastFrameTime: 0,
            state: 'idle', facing: 'right',
            basket: [],
            task: null,
            stateTimer: 0,
            idleX: 0, idleY: 0,
            onBreak: false,
            playerInitiatedBreak: false
        };

        const cashier = {
            x: 100, y: 300, width: 50, height: 50, speed: 200,
            currentFrame: 0, frameWidth: 90, frameHeight: 90,
            animationSpeed: 150, lastFrameTime: 0,
            state: 'idle', facing: 'right',
            task: null,
            stateTimer: 0,
            idleX: 0, idleY: 0,
            onBreak: false,
            playerInitiatedBreak: false,
            basket: []
        };

        const loader = {
            x: 600, y: 600, width: 50, height: 50, speed: 160,
            currentFrame: 0, frameWidth: 90, frameHeight: 90,
            animationSpeed: 150, lastFrameTime: 0,
            state: 'idle', facing: 'right',
            basket: [],
            task: null,
            stateTimer: 0,
            idleX: 0, idleY: 0,
            onBreak: false,
            playerInitiatedBreak: false
        };
        const manager = {
            x: 200, y: 300, width: 50, height: 50, speed: 150,
            currentFrame: 0, frameWidth: 90, frameHeight: 90,
            animationSpeed: 150, lastFrameTime: 0,
            state: 'idle', facing: 'right',
            task: null,
            stateTimer: 5000,
            idleX: 0, idleY: 0,
            onBreak: false,
            playerInitiatedBreak: false,
            canOrder: true,
            lastOrderQuarter: -1,
                hasPlacedMorningOrder: false,
        };

        const salesperson = {
            x: 400, y: 400, width: 50, height: 50, speed: 120,
            currentFrame: 0, frameWidth: 90, frameHeight: 90,
            animationSpeed: 150, lastFrameTime: 0,
            state: 'idle', facing: 'right',
            task: null,
            stateTimer: 0,
            idleX: 0, idleY: 0,
            onBreak: false,
            playerInitiatedBreak: false,
            basket: []
        };

        const breakSpots = {
            cashier:     { x: 30, y: 15 }, // Top chair
            stocker:     { x: 60, y: 65 }, // Bottom chair
            loader:      { x: 10, y: 40 }, // Left of table
            manager:     { x: 85, y: 40 }, // Right of table
            salesperson: { x: 45, y: 40 }  // Center of table
        };

        function getBreakSpot(employeeKey) {
            const spot = breakSpots[employeeKey];
            // The break spot coordinates are relative to the break room (officeZone3)
            return {
                x: officeZone3.x + spot.x,
                y: officeZone3.y + spot.y
            };
        }

        const animations = {
            'idle': { startFrame: 0, frames: 3, cols: 3 },
            'walk': { startFrame: 3, frames: 3, cols: 3 }
        };

        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });
        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            if (e.code === 'KeyF') {
                 // Legacy keybind, now opens phone to orders
                openPhonePanel();
                showAppScreen('restock-panel');
            } else if (e.code === 'KeyG') {
                // Legacy keybind, now opens phone to basket
                openPhonePanel();
                showAppScreen('basket-panel');
            } else if (e.code === 'KeyT') {
                // Legacy keybind, now opens phone to unlocks
                openPhonePanel();
                showAppScreen('unlocks-panel');
            } else if (e.code === 'KeyE') {
                handleInteraction();
            } else if (e.code === 'Escape') {
                if (isPhoneOpen) {
                    if (activePhoneScreen) {
                        showAppGrid(); // Go back to app grid
                    } else {
                        closePhone(); // Close phone from app grid
                    }
                } else if (activePanel) {
                    // Handle legacy panels if any are still in use
                    togglePanel(activePanel, false);
                }
            }
        });


        const items = {
            // Drawing (formerly General)
            'Pencil': { cost: 1 }, 'Charcoal': { cost: 2 }, 'Markers': { cost: 5 }, 'Sketchbook': { cost: 10 },
            // Painting (formerly Quality)
            'Water Color': { cost: 5 }, 'Oils': { cost: 5 }, 'Acrylics': { cost: 10 }, 'Canvas': { cost: 20 },
            // Models
            'Razors': { cost: 5 }, 'Glue': { cost: 7 }, 'Mini Paints': { cost: 20 }, 'Model Kits': { cost: 50 },
            // Woodworking (formerly Sculpture)
            'Sanding Paper': { cost: 10 }, 'Stainer': { cost: 20 }, 'Wood Scraps': { cost: 50 }, 'Lumber': { cost: 100 },
            // Sculpture (formerly Painting)
            'Clay': { cost: 20 }, 'Pottery Paints': { cost: 50 }, 'Stone': { cost: 150 }, 'Marble': { cost: 300 },
            // Architectural (formerly Drawing)
            'Pencil Lead': { cost: 20 }, 'Vellum': { cost: 75 }, 'Fancy Markers': { cost: 100 }, 'Tiny Trees': { cost: 200 }
        };

        let inventory = {};
        // Initialize inventory for a new game. This will be overwritten by loadGame if a save exists.
        Object.keys(items).forEach(item => inventory[item] = 5);

        class Customer {
            constructor(profile, name, request, requestedItems, customerType) {
                this.id = Math.random();
                this.profile = profile; // Reference to the persistent profile
                this.name = name;
                this.request = request;
                this.requestedItems = requestedItems;
                this.customerType = customerType;
                this.patience = this.profile.patience; // Use persistent patience
                this.initialPatience = this.profile.patience; // For sales report
                this.waitTimer = 0; // New timer for interaction logic
                this.discount = 0; // Discount for special interactions
                this.budget = Math.floor(Math.random() * 91) + 10;
                this.x = canvas.width + 50;
                this.y = desk.y + 75;
                this.targetX = canvas.width - 150;
                this.targetY = desk.y + 75;
                this.speed = 80;
                this.isServed = false;
                this.leaving = false;

                this.state = 'entering';
                this.isInteractedWith = false;
                this.needsAssistanceFulfilled = false;
                this.hasReachedWaitingPoint = false;

                const rand = Math.random();
                if (rand < 0.4) {
                    this.behaviorType = 'direct';
                } else if (rand < 0.8) {
                    this.behaviorType = 'needsInteraction';
                } else {
                    this.behaviorType = 'needsAssistance';
                }
                this.facing = 'left';
                this.currentFrame = 0;
                this.lastFrameTime = 0;
                this.animationSpeed = 150;
                this.frameWidth = 90;
                this.frameHeight = 90;
                this.speechBubbleTimer = 0;
                this.showSpeechBubble = false;
                this.order = [];
                this.stateTimer = 0;
                this.currentItemIndex = 0;
                this.isWaitingForRestock = false;

                this.spriteImage = new Image();
                this.spriteSheetLoaded = false;
            }

            draw() {
                if (this.spriteSheetLoaded) {
                    drawCharacter(this, this.spriteImage, '', '', false);
                }

                if (this.showSpeechBubble) {
                    const bubbleWidth = 200, bubbleHeight = 80;
                    const bubbleX = this.x - bubbleWidth / 2, bubbleY = this.y - 185;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.strokeStyle = '#5d4037';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(bubbleX + 10, bubbleY); ctx.lineTo(bubbleX + bubbleWidth - 10, bubbleY);
                    ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + 10);
                    ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - 10);
                    ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - 10, bubbleY + bubbleHeight);
                    ctx.lineTo(this.x + 10, bubbleY + bubbleHeight); ctx.lineTo(this.x, this.y - 80); ctx.lineTo(this.x - 10, bubbleY + bubbleHeight);
                    ctx.lineTo(bubbleX + 10, bubbleY + bubbleHeight);
                    ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - 10);
                    ctx.lineTo(bubbleX, bubbleY + 10);
                    ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + 10, bubbleY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = '#5d4037';
                    ctx.font = '16px "Patrick Hand", cursive';
                    ctx.textAlign = 'center';
                    wrapText(ctx, this.request, this.x, bubbleY + 20, bubbleWidth - 20, 20);
                }

                ctx.font = '20px "Indie Flower", cursive';
                ctx.textAlign = 'center';
                const displayName = this.profile.isStarred ? `⭐ ${this.name}` : this.name;
                ctx.fillText(displayName, this.x, this.y - this.frameHeight);
            }

            findNextItemTarget() {
                const itemToFind = this.requestedItems[this.currentItemIndex];
                const targetShelf = shelves.find(s => s.items.some(i => i && i.assignedItem === itemToFind && i.quantity > 0));
                 if (targetShelf) {
                     this.targetX = targetShelf.rect.x + targetShelf.rect.w / 2;
                     this.targetY = targetShelf.rect.y + targetShelf.rect.h + 20;
                     return true;
                 }
                return false;
            }

            update(deltaTime) {
                if (this.state !== 'leaving' && dayPhase === 'closing') {
                    logCustomerToSalesReport(this);
                    this.state = 'leaving';
                    this.request = "Oh, it's closing time! I'll come back another day.";
                }

                const anim = animations[this.state === 'idle' || this.state === 'waitingAtCounter' || (this.state === 'waitingForInteraction' && this.hasReachedWaitingPoint) ? 'idle' : 'walk'];
                this.lastFrameTime += deltaTime;
                if (this.lastFrameTime >= this.animationSpeed) {
                    this.currentFrame = (this.currentFrame + 1) % anim.frames;
                    this.lastFrameTime = 0;
                }
                if (this.speechBubbleTimer > 0) {
                    this.speechBubbleTimer -= deltaTime;
                    if (this.speechBubbleTimer <= 0) {
                        this.showSpeechBubble = false;
                    }
                }
                switch(this.state) {
                    case 'entering':
                        this.targetY = desk.y + 75;
                        if (this.moveTowardsTarget(deltaTime)) {
                            switch (this.behaviorType) {
                                case 'direct':
                                    this.state = 'browsing';
                                    if (!this.findNextItemTarget()) {
                                        this.request = `Hmm, I don't see any ${this.requestedItems[0]}. I'll look around.`;
                                        this.state = 'wandering';
                                        this.isWaitingForRestock = true;
                                        this.stateTimer = 0;
                                    }
                                    break;
                                case 'needsInteraction':
                                    this.state = 'waitingForInteraction';
                                    this.request = "Hello? Could someone help me find something?";
                                    this.showSpeechBubble = true;
                                    this.speechBubbleTimer = 5000;
                                    // Set target to a point past the shelves
                                    const firstShelfX = shelves[0].rect.x;
                                    const lastShelf = shelves[shelves.length - 1];
                                    const lastShelfX = lastShelf.rect.x + lastShelf.rect.w;
                                    this.targetX = (firstShelfX + lastShelfX) / 2; // Middle of aisle
                                    this.targetY = shelves[0].rect.y + shelves[0].rect.h + 40; // Below shelves
                                    break;
                                case 'needsAssistance':
                                    this.state = 'waitingForAssistance';
                                    this.request = "Could someone get these items for me, please?";
                                    this.showSpeechBubble = true;
                                    this.speechBubbleTimer = 5000;
                                    // Start wandering
                                    this.stateTimer = 0;
                                    break;
                            }
                        }
                        break;
                    case 'browsing':
                        if (this.moveTowardsTarget(deltaTime)) {
                            this.state = 'takingItem';
                            this.stateTimer = 1000;
                        }
                        break;
                    case 'takingItem':
                        this.stateTimer -= deltaTime;
                        if (this.stateTimer <= 0) {
                            const currentItem = this.requestedItems[this.currentItemIndex];
                            const shelf = shelves.find(s => s.items.some(i => i && i.assignedItem === currentItem));
                            if(shelf) {
                                const slot = shelf.items.find(i => i && i.assignedItem === currentItem && i.quantity > 0);
                                if (slot) {
                                    slot.quantity--;
                                    this.order.push(currentItem);
                                    this.currentItemIndex++; // <-- FIX: This was missing!
                                     if(this.currentItemIndex >= this.requestedItems.length) {
                                         this.request = `Got everything! Time to check out.`;
                                         this.state = 'queuing';
                                     } else {
                                         this.state = 'browsing';
                                         if(!this.findNextItemTarget()){
                                             this.request = `Can't find the other items... I'll just look around.`;
                                             this.state = 'wandering';
                                             this.isWaitingForRestock = true;
                                             this.stateTimer = 0;
                                         }
                                     }
                                } else {
                                    this.request = `They're out of ${currentItem}!`;
                                    logCustomerToSalesReport(this);
                                    this.state = 'leaving';
                                }
                            } else {
                                 this.request = `They're out of ${currentItem}!`;
                                 logCustomerToSalesReport(this);
                                 this.state = 'leaving';
                            }
                        }
                        break;
                    case 'wandering':
                        this.waitTimer += (deltaTime / 1000); // Start waiting (in seconds)
                        this.stateTimer -= deltaTime;
                        if (this.stateTimer <= 0 || this.moveTowardsTarget(deltaTime)) {
                            this.stateTimer = Math.random() * 4000 + 2000; // Wander for 2-6 seconds

                            if (this.isWaitingForRestock && this.findNextItemTarget()) {
                                this.state = 'browsing';
                                this.request = `Oh, they have the ${this.requestedItems[this.currentItemIndex]} now!`;
                                this.isWaitingForRestock = false;
                                this.waitTimer = 0; // Reset timer
                                return;
                            }

                            const firstShelfX = shelves[0].rect.x;
                            const lastShelf = shelves[shelves.length - 1];
                            const lastShelfX = lastShelf.rect.x + lastShelf.rect.w;
                            const shelfYArea = shelves[0].rect.y + shelves[0].rect.h + 60;

                            this.targetX = Math.random() * (lastShelfX - firstShelfX) + firstShelfX;
                            this.targetY = Math.random() * 100 + shelfYArea - 50;
                        }
                        break;
                    case 'waitingForInteraction':
                        if (!this.hasReachedWaitingPoint) {
                            if (this.moveTowardsTarget(deltaTime)) {
                                this.hasReachedWaitingPoint = true;
                                this.facing = 'down'; // Face forward
                            }
                        } else {
                            this.waitTimer += (deltaTime / 1000); // Start waiting once in position (in seconds)
                        }

                        if (this.isInteractedWith) {
                            this.waitTimer = 0; // Reset wait timer
                            this.state = 'browsing';
                            this.request = "Ah, thank you! Let me see...";
                            this.showSpeechBubble = true;
                            this.speechBubbleTimer = 3000;
                            if (!this.findNextItemTarget()) {
                                this.request = `Hmm, I still don't see what I need. I'll look around.`;
                                this.state = 'wandering';
                                this.isWaitingForRestock = true;
                                this.stateTimer = 0;
                            }
                        }
                        break;
                    case 'waitingForAssistance':
                        this.waitTimer += (deltaTime / 1000); // Start waiting (in seconds)
                        // Wander around until order is fulfilled
                        this.stateTimer -= deltaTime;
                        if (this.stateTimer <= 0 || this.moveTowardsTarget(deltaTime)) {
                            this.stateTimer = Math.random() * 5000 + 3000;
                            const firstShelfX = shelves[0].rect.x;
                            const lastShelf = shelves[shelves.length - 1];
                            const lastShelfX = lastShelf.rect.x + lastShelf.rect.w;
                            const shelfYArea = shelves[0].rect.y + shelves[0].rect.h + 60;
                            this.targetX = Math.random() * (lastShelfX - firstShelfX) + firstShelfX;
                            this.targetY = Math.random() * 100 + shelfYArea - 50;
                        }
                        // The check for fulfillment will be external (player/salesperson)
                        // and will change the customer's state directly to 'queuing'.
                        break;
                    case 'queuing':
                    case 'waitingAtCounter': {
                        const waitingCustomers = customers
                            .filter(c => ['queuing', 'waitingAtCounter'].includes(c.state))
                            .sort((a,b) => a.x - b.x);
                        const myQueueIndex = waitingCustomers.findIndex(c => c.id === this.id);
                        if (myQueueIndex !== -1) {
                             this.targetX = cashierCounter.x + cashierCounter.w + 60 + myQueueIndex * 90;
                             this.targetY = cashierCounter.y + cashierCounter.h / 2;
                        }
                        if (this.state === 'queuing' && this.moveTowardsTarget(deltaTime)) {
                            this.state = 'waitingAtCounter';
                        } else {
                            this.moveTowardsTarget(deltaTime);
                        }
                        break;
                    }
                    case 'leaving':
            this.targetX = worldWidth + 100;
                        this.targetY = desk.y + 75;
                        this.moveTowardsTarget(deltaTime);
                        break;
                }
            }

            moveTowardsTarget(deltaTime) {
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist < 5) return true;
                const moveX = (dx / dist) * this.speed * (deltaTime / 1000);
                const moveY = (dy / dist) * this.speed * (deltaTime / 1000);
                this.x += moveX;
                this.y += moveY;
                this.facing = moveX > 0 ? 'right' : 'left';
                return false;
            }
        }

        function wrapText(context, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const testWidth = context.measureText(testLine).width;
                if (testWidth > maxWidth && n > 0) {
                    context.fillText(line, x, y);
                    line = words[n] + ' ';
                    y += lineHeight;
                } else {
                    line = testLine;
                }
            }
            context.fillText(line, x, y);
        }

        function drawLoadingDock() {
            ctx.save(); // Save context state

            // Create a clipping path for the loading dock area
            ctx.beginPath();
            ctx.rect(loadingDock.x, loadingDock.y, loadingDock.width, loadingDock.height);
            ctx.clip();

            ctx.fillStyle = 'rgba(255, 235, 59, 0.3)'; // Light yellow background
            ctx.fillRect(loadingDock.x, loadingDock.y, loadingDock.width, loadingDock.height);

            ctx.strokeStyle = 'rgba(255, 193, 7, 0.6)'; // Darker yellow for hatching
            ctx.lineWidth = 4;
            const spacing = 40;
            ctx.beginPath();
            // Draw hatching lines that cover the entire visible canvas, but will be clipped
            for (let i = -canvas.height; i < worldWidth; i += spacing) {
                ctx.moveTo(i, canvas.height);
                ctx.lineTo(i + loadingDock.height, loadingDock.y);
            }
             for (let i = worldWidth + canvas.height; i > 0; i -= spacing) {
                ctx.moveTo(i, canvas.height);
                ctx.lineTo(i - loadingDock.height, loadingDock.y);
            }
            ctx.stroke();

            ctx.restore(); // Restore context state, removing the clip

            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 2;
            ctx.strokeRect(loadingDock.x, loadingDock.y, loadingDock.width, loadingDock.height-1);
        }

        function drawManagersOffice() {
            ctx.fillStyle = '#a1887f';
            ctx.fillRect(managersOffice.x, managersOffice.y, managersOffice.w, managersOffice.h);
            ctx.strokeStyle = '#4e342e';
            ctx.lineWidth = 4;
            ctx.strokeRect(managersOffice.x, managersOffice.y, managersOffice.w, managersOffice.h);
            ctx.fillStyle = '#5d4037';
            ctx.font = '14px "Indie Flower", cursive';
            ctx.textAlign = 'center';
            ctx.fillText("Manager's", managersOffice.x + managersOffice.w / 2, managersOffice.y + 20);
            ctx.fillText("Office", managersOffice.x + managersOffice.w / 2, managersOffice.y + 35);

            // Desk
            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(managersOffice.x + 20, managersOffice.y + 50, 60, 30);
            ctx.strokeRect(managersOffice.x + 20, managersOffice.y + 50, 60, 30);
        }

        function drawOfficeZones() {
            // Player's Desk Area (Zone 1) - Rotated Desk
            const deskWidth = 15;
            const deskHeight = officeZone1.h * 0.8;
            const deskX = officeZone1.x + officeZone1.w - deskWidth - 5; // Move slightly left
            const deskY = officeZone1.y + (officeZone1.h - deskHeight) / 2;

            // Desk
            ctx.fillStyle = '#8d6e63'; // Brown color
            ctx.fillRect(deskX, deskY, deskWidth, deskHeight);
            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 2;
            ctx.strokeRect(deskX, deskY, deskWidth, deskHeight);

            // Computer
            const pcWidth = 25;
            const pcHeight = 30;
            const pcX = deskX - pcWidth + 5; // Positioned to the left of the desk
            const pcY = deskY + (deskHeight - pcHeight) / 2;
            ctx.fillStyle = '#333';
            ctx.fillRect(pcX, pcY, pcWidth, pcHeight);
            ctx.fillStyle = '#555'; // Screen
            ctx.fillRect(pcX + 3, pcY + 3, pcWidth - 8, pcHeight - 6);


            // Lounge Area (Zone 2) - Rotated Couch
            const couchWidth = officeZone2.h * 0.9; // Swapped w/h for rotation
            const couchHeight = officeZone2.w * 0.4;
            const couchX = officeZone2.x + (officeZone2.w - couchHeight) / 2;
            const couchY = officeZone2.y + (officeZone2.h - couchWidth) / 2;
            ctx.fillStyle = '#a1887f'; // Lighter brown for couch
            ctx.fillRect(couchX, couchY, couchHeight, couchWidth);
            ctx.fillStyle = '#795548'; // Darker brown for details
            ctx.fillRect(couchX, couchY, couchHeight, 8); // Top arm (was base)
            ctx.fillRect(couchX, couchY, 8, couchWidth); // Left arm (was left arm)
            ctx.fillRect(couchX + couchHeight - 8, couchY, 8, couchWidth); // Right arm


            // Break Room (Zone 3)
            const tableWidth = officeZone3.w * 0.6;
            const tableHeight = 10;
            const tableX = officeZone3.x + (officeZone3.w - tableWidth) / 2;
            const tableY = officeZone3.y + (officeZone3.h - tableHeight) / 2;
            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(tableX, tableY, tableWidth, tableHeight);
            ctx.strokeRect(tableX, tableY, tableWidth, tableHeight);

            // Chairs
            const chairWidth = 15;
            const chairHeight = 18;
            // Chair 1 (Top)
            ctx.fillStyle = '#a1887f';
            ctx.fillRect(tableX + 10, tableY - chairHeight + 5, chairWidth, chairHeight);
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(tableX + 10, tableY - chairHeight + 5, chairWidth, 4); // Backrest
            // Chair 2 (Bottom)
            ctx.fillStyle = '#a1887f';
            ctx.fillRect(tableX + tableWidth - 25, tableY + tableHeight - 5, chairWidth, chairHeight);
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(tableX + tableWidth - 25, tableY + tableHeight + chairHeight - 9, chairWidth, 4); // Backrest

        }

        function drawPackage(pkg, x, y) {
            ctx.fillStyle = '#b9936c';
            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 2;
            ctx.fillRect(x, y, PACKAGE_WIDTH, PACKAGE_HEIGHT);
            ctx.strokeRect(x, y, PACKAGE_WIDTH, PACKAGE_HEIGHT);

            // Tape
            ctx.fillStyle = 'rgba(160, 120, 80, 0.7)';
            ctx.fillRect(x + PACKAGE_WIDTH/2 - 5, y, 10, PACKAGE_HEIGHT);
            ctx.fillRect(x, y + PACKAGE_HEIGHT/2 - 5, PACKAGE_WIDTH, 10);

            // Label
            ctx.fillStyle = 'white';
            ctx.fillRect(x + 5, y + 5, PACKAGE_WIDTH - 10, 20);
            ctx.fillStyle = '#5d4037';
            ctx.font = '14px "Patrick Hand"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${pkg.itemName} (${pkg.quantity})`, x + PACKAGE_WIDTH/2, y + 15);
        }

        function drawPackages() {
            loadingDockPackages.forEach((pkg, index) => {
                const x = 10 + index * (PACKAGE_WIDTH + 10);
                const y = loadingDock.y + (loadingDock.height - PACKAGE_HEIGHT) / 2;
                drawPackage(pkg, x, y);
            });
        }

        function drawStoreBackground() {
            ctx.fillStyle = '#bcaaa4';
            ctx.fillRect(0, 0, worldWidth, canvas.height);
            ctx.fillStyle = '#a1887f';
            ctx.fillRect(0, 0, worldWidth, desk.y + desk.height);
            storageCells.forEach((cell, index) => {
                if (!unlocks.storage[index]) {
                    const r = cell.rect;
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(r.x, r.y, r.w, r.h);
                    drawLockIcon(r.x + r.w/2 - 25, r.y + r.h/2 - 25, 50, 50);
                    return;
                }

                const r = cell.rect;
                const perspective = 0.25;
                const insetX = r.w * perspective;
                const insetY = r.h * perspective;

                const backWall = {
                    x: r.x + insetX,
                    y: r.y + insetY,
                    w: r.w - insetX * 2,
                    h: r.h - insetY * 2
                };

                ctx.fillStyle = '#d7ccc8';
                ctx.fillRect(r.x, r.y, r.w, r.h);

                ctx.fillStyle = '#bcaaa4';
                ctx.fillRect(backWall.x, backWall.y, backWall.w, backWall.h);

                ctx.strokeStyle = '#5d4037';
                ctx.lineWidth = 3;

                ctx.beginPath();
                ctx.moveTo(r.x, r.y); ctx.lineTo(backWall.x, backWall.y);
                ctx.moveTo(r.x + r.w, r.y); ctx.lineTo(backWall.x + backWall.w, backWall.y);
                ctx.moveTo(r.x, r.y + r.h); ctx.lineTo(backWall.x, backWall.y + backWall.h);
                ctx.moveTo(r.x + r.w, r.y + r.h); ctx.lineTo(backWall.x + backWall.w, backWall.y + backWall.h);
                ctx.stroke();

                ctx.strokeRect(r.x, r.y, r.w, r.h);
                ctx.strokeRect(backWall.x, backWall.y, backWall.w, backWall.h);

                // Capacity Bar
                const currentFill = Object.values(cell.items).reduce((a, b) => a + b, 0);
                const fillPercent = Math.min(1, currentFill / cell.capacity);
                ctx.fillStyle = '#eeeeee';
                ctx.fillRect(backWall.x + 5, backWall.y + backWall.h - 15, backWall.w - 10, 10);
                ctx.fillStyle = '#76ff03';
                ctx.fillRect(backWall.x + 5, backWall.y + backWall.h - 15, (backWall.w - 10) * fillPercent, 10);
                ctx.strokeStyle = '#5d4037';
                ctx.strokeRect(backWall.x + 5, backWall.y + backWall.h - 15, backWall.w - 10, 10);

                ctx.fillStyle = '#5d4037';
                ctx.font = '18px "Indie Flower", cursive';
                ctx.textAlign = 'center';
                ctx.fillText(cell.label, cell.rect.x + cell.rect.w / 2, cell.rect.y + cell.rect.h + 20);
            });

            // Draw Cashier Counter
            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(cashierCounter.x, cashierCounter.y, cashierCounter.w, cashierCounter.h);
            ctx.strokeStyle = '#4e342e';
            ctx.lineWidth = 4;
            ctx.strokeRect(cashierCounter.x, cashierCounter.y, cashierCounter.w, cashierCounter.h);
            ctx.fillStyle = '#6d4c41'; // Darker top
            ctx.fillRect(cashierCounter.x, cashierCounter.y, 10, cashierCounter.h);


            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(desk.x, desk.y, desk.width, desk.height);
            ctx.strokeStyle = '#4e342e';
            ctx.lineWidth = 4;
            ctx.strokeRect(desk.x, desk.y, desk.width, desk.height);

            drawLoadingDock();
            drawManagersOffice();
        }

        function drawStaticUI() {
            const boxWidth = 70, boxHeight = 70;
            const boxX = (canvas.width - boxWidth) / 2, boxY = 20;

            ctx.fillStyle = "rgba(93, 64, 55, 0.7)";
            ctx.strokeStyle = "#4e342e";
            ctx.lineWidth = 2;
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

            const iconY = boxY + 10;
            phoneIcon.x = boxX + 10; phoneIcon.y = iconY;

            drawPhoneIcon(phoneIcon.x, phoneIcon.y, phoneIcon.width, phoneIcon.height);
        }

        function drawCashRegister(x, y, w, h) {
            ctx.fillStyle = '#c0c0c0'; ctx.fillRect(x, y, w, h);
            ctx.fillStyle = '#808080'; ctx.fillRect(x + 5, y + 5, w - 10, 15);
            ctx.fillStyle = '#333';
            ctx.fillRect(x + 8, y + 25, w * 0.4, h * 0.3);
            const btnW = w * 0.15; const btnH = h * 0.18;
            ctx.fillRect(x + w * 0.6, y + 25, btnW, btnH);
            ctx.fillRect(x + w * 0.8, y + 25, btnW, btnH);
            ctx.fillRect(x + w * 0.6, y + 25 + btnH + 5, btnW, btnH);
            ctx.fillRect(x + w * 0.8, y + 25 + btnH + 5, btnW, btnH);
        }

        function drawClipboard(x, y, w, h) {
             ctx.fillStyle = '#8d6e63'; ctx.fillRect(x, y, w, h);
             ctx.fillStyle = '#f5f5f5'; ctx.fillRect(x + 5, y + 15, w - 10, h - 20);
             ctx.fillStyle = '#757575'; ctx.fillRect(x + 10, y + 5, w - 20, 10);
             ctx.strokeStyle = '#bdbdbd'; ctx.lineWidth = 1;
             for (let i = 0; i < 4; i++) {
                 ctx.beginPath();
                 ctx.moveTo(x + 10, y + 25 + i * 8);
                 ctx.lineTo(x + w - 10, y + 25 + i * 8);
                 ctx.stroke();
             }
        }

        function drawShoppingBasket(x, y, w, h) {
            ctx.strokeStyle = '#f5f5f5';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + w * 0.1, y + h * 0.4);
            ctx.lineTo(x + w * 0.9, y + h * 0.4);
            ctx.lineTo(x + w * 0.8, y + h * 0.9);
            ctx.lineTo(x + w * 0.2, y + h * 0.9);
            ctx.closePath();
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + w * 0.3, y + h * 0.4);
            ctx.quadraticCurveTo(x + w * 0.5, y, x + w * 0.7, y + h * 0.4);
            ctx.stroke();
        }

        function drawLockIcon(x, y, w, h) {
            ctx.strokeStyle = '#f5f5f5';
            ctx.lineWidth = 4;

            // Shackle (the U part)
            ctx.beginPath();
            ctx.moveTo(x + w * 0.25, y + h * 0.4);
            ctx.lineTo(x + w * 0.25, y + h * 0.2);
            ctx.arc(x + w * 0.5, y + h * 0.2, w * 0.25, Math.PI, 0);
            ctx.lineTo(x + w * 0.75, y + h * 0.4);
            ctx.stroke();

            // Body (the square part)
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(x, y + h * 0.4, w, h * 0.6);
        }

        function drawPhoneIcon(x, y, w, h) {
            ctx.fillStyle = '#f5f5f5';
            ctx.strokeStyle = '#f5f5f5';
            ctx.lineWidth = 3;

            // Phone body
            ctx.beginPath();
            ctx.roundRect(x + w * 0.15, y, w * 0.7, h, 8);
            ctx.fill();

            // Screen
            ctx.fillStyle = '#333';
            ctx.fillRect(x + w * 0.25, y + 8, w * 0.5, h - 24);

            // Home button
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + w * 0.5, y + h - 8, 4, 0, Math.PI * 2);
            ctx.stroke();
        }

        // --- START: Sprite Sheet Generation Code ---

        // This function generates the original flower-headed sprite for the player and NPCs
        function generateOriginalSpriteSheet(canvas, ctx) {
             const frameSize = 90;
             const sheetSize = 270;
             const colors = {
                 skin: '#f2d3b3', petal: '#ffc0cb', flowerCenter: '#ffee00',
                 top: '#f8f8f8', shorts: '#6E98D9', shoes: '#2d2d2d',
                 white: '#ffffff', outline: '#333333'
             };
             function drawFlowerHead(x, y, isSideView = false) {
                 const centerX = x + frameSize / 2;
                 const centerY = y + 25;
                 const petalRadius = 14;
                 const centerRadius = 5;
                 ctx.strokeStyle = colors.outline;
                 ctx.lineWidth = 1.5;
                 ctx.fillStyle = colors.petal;
                 if (isSideView) {
                     const sidePetals = [
                         { angle: Math.PI / 2, xOff: 0, yOff: -3, size: 1.1 },
                         { angle: Math.PI * 0.1, xOff: 5, yOff: 2, size: 1.0 },
                         { angle: Math.PI * 0.9, xOff: -5, yOff: 2, size: 1.0 },
                     ];
                     sidePetals.forEach(p => {
                         ctx.beginPath();
                         ctx.ellipse(centerX + p.xOff, centerY + p.yOff, 5 * p.size, 8 * p.size, p.angle, 0, Math.PI * 2);
                         ctx.fill();
                         ctx.stroke();
                     });
                 } else {
                     const numPetals = 6;
                     for (let i = 0; i < numPetals; i++) {
                         const angle = (i / numPetals) * Math.PI * 2;
                         const px = centerX + Math.cos(angle) * petalRadius;
                         const py = centerY + Math.sin(angle) * petalRadius;
                         ctx.beginPath();
                         ctx.ellipse(px, py, 6, 10, angle + Math.PI / 2, 0, Math.PI * 2);
                         ctx.fill();
                         ctx.stroke();
                     }
                 }
                 ctx.fillStyle = colors.flowerCenter;
                 ctx.beginPath();
                 ctx.arc(centerX, centerY, centerRadius, 0, Math.PI * 2);
                 ctx.fill();
                 ctx.stroke();
             }
             function drawBody(x, y, bob = 0) {
                 ctx.fillStyle = colors.top;
                 ctx.strokeStyle = colors.outline;
                 ctx.lineWidth = 1.5;
                 ctx.beginPath();
                 ctx.moveTo(x + 38, y + 40 + bob);
                 ctx.lineTo(x + 52, y + 40 + bob);
                 ctx.lineTo(x + 55, y + 55 + bob);
                 ctx.lineTo(x + 35, y + 55 + bob);
                 ctx.closePath();
                 ctx.fill();
                 ctx.stroke();
                 ctx.fillStyle = colors.shorts;
                 ctx.beginPath();
                 ctx.rect(x + 35, y + 55 + bob, 20, 10);
                 ctx.fill();
                 ctx.stroke();
             }
             function drawLegs(x, y, frame = 1, bob = 0, isSideView = false) {
                 const legY = y + 65 + bob;
                 ctx.fillStyle = colors.skin;
                 ctx.strokeStyle = colors.outline;
                 ctx.lineWidth = 1.5;
                 let leftLegX = x + 38, rightLegX = x + 48, leftLegYOffset = 0, rightLegYOffset = 0;
                 if (isSideView) {
                     leftLegX = x + 42; rightLegX = x + 46;
                     if (frame === 1) { leftLegYOffset = 5; rightLegYOffset = 0; }
                     else if (frame === 2) { leftLegYOffset = 0; rightLegYOffset = 5; }
                 } else {
                     if (frame === 2) { rightLegYOffset = 2; }
                     else if (frame !== 1) { leftLegYOffset = 2; }
                 }
                 ctx.beginPath(); ctx.rect(rightLegX, legY + rightLegYOffset, 4, 15); ctx.fill(); ctx.stroke();
                 drawShoe(rightLegX, legY + 15 + rightLegYOffset, isSideView);
                 ctx.beginPath(); ctx.rect(leftLegX, legY + leftLegYOffset, 4, 15); ctx.fill(); ctx.stroke();
                 drawShoe(leftLegX, legY + 15 + leftLegYOffset, isSideView);
             }
             function drawShoe(x, y, isSideView) {
                 ctx.fillStyle = colors.shoes; ctx.strokeStyle = colors.outline; ctx.lineWidth = 1.5;
                 ctx.beginPath();
                 if(isSideView){ ctx.rect(x-3, y, 8, 5); } else { ctx.rect(x - 2, y, 8, 5); }
                 ctx.fill(); ctx.stroke();
                 ctx.fillStyle = colors.white;
                 ctx.beginPath();
                 if(isSideView){ ctx.rect(x+5, y, 2, 5); } else { ctx.rect(x - 2, y, 8, 2); }
                 ctx.fill();
             }
             function drawIdleFrame(col, row) {
                 const x = col * frameSize, y = row * frameSize;
                 const bob = (col === 1) ? 1 : 0;
                 drawBody(x, y, bob); drawLegs(x, y, 1, bob); drawFlowerHead(x, y);
             }
             function drawWalkDownFrame(col, row) {
                 const x = col * frameSize, y = row * frameSize;
                 const frame = (col % 2 === 0) ? (col === 0 ? 3 : 1) : 2;
                 drawBody(x, y); drawLegs(x, y, frame); drawFlowerHead(x, y);
             }
             function drawWalkRightFrame(col, row) {
                 const x = col * frameSize, y = row * frameSize;
                 const frame = (col % 2 === 0) ? (col === 0 ? 3 : 1) : 2;
                 drawBody(x, y); drawLegs(x, y, frame, 0, true); drawFlowerHead(x, y, true);
             }
             ctx.clearRect(0, 0, sheetSize, sheetSize);
             for (let row = 0; row < 3; row++) {
                 for (let col = 0; col < 3; col++) {
                     if (row === 0) { drawIdleFrame(col, row); }
                     else if (row === 1) { drawWalkDownFrame(col, row); }
                     else if (row === 2) { drawWalkRightFrame(col, row); }
                 }
             }
        }

        // This new function generates the bee sprites for customers
        function generateBeeSpriteSheet(canvas, ctx, artistType) {
            const frameSize = 90;
            const sheetSize = 270;
            const colors = {
                beeYellow: '#ffdd00', beeBlack: '#4a4a4a', wingBlue: 'rgba(169, 214, 229, 0.8)',
                outline: '#333333', beretRed: '#c0392b', paintBlue: '#3498db', paintRed: '#e74c3c',
                paintGreen: '#2ecc71', paletteBrown: '#8d6e63', glassesGray: '#7f8c8d', lightYellow: '#f1c40f',
                apronBlue: '#2c3e50', sawGray: '#bdc3c7', woodBrown: '#a0522d', clayGray: '#95a5a6',
                toolBrown: '#8B4513', smockGray: '#bdc3c7', bagBrown: '#8B5A2B', paperWhite: '#f5f5f5'
            };

            function drawBeeHead(ctx, x, y, isSideView = false, currentArtistType = '') {
                const centerX = x + frameSize / 2;
                const centerY = y + 30;
                ctx.strokeStyle = colors.outline;
                ctx.lineWidth = 1.5;
                ctx.fillStyle = colors.beeYellow;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 15, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = colors.beeBlack;
                if(currentArtistType === 'modelMaker'){
                    ctx.fillStyle = colors.glassesGray;
                    ctx.strokeStyle = colors.outline;
                    ctx.lineWidth = 1;
                    if(isSideView){
                        ctx.beginPath();
                        ctx.arc(centerX + 6, centerY, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = colors.beeBlack;
                        ctx.beginPath();
                        ctx.arc(centerX + 6, centerY, 4, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.arc(centerX - 7, centerY, 6, 0, Math.PI * 2);
                        ctx.arc(centerX + 7, centerY, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = colors.beeBlack;
                        ctx.beginPath();
                        ctx.arc(centerX - 7, centerY, 4, 0, Math.PI * 2);
                        ctx.arc(centerX + 7, centerY, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.fillStyle = colors.glassesGray;
                    ctx.fillRect(centerX - 5, centerY - 22, 10, 4);
                    ctx.strokeRect(centerX - 5, centerY - 22, 10, 4);
                    ctx.fillStyle = colors.lightYellow;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY - 20, 2, 0, Math.PI*2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    if (isSideView) {
                        ctx.ellipse(centerX + 6, centerY, 3, 4, 0, 0, Math.PI * 2);
                    } else {
                        ctx.ellipse(centerX - 7, centerY, 3, 4, 0, 0, Math.PI * 2);
                        ctx.ellipse(centerX + 7, centerY, 3, 4, 0, 0, Math.PI * 2);
                    }
                    ctx.fill();
                }
                ctx.strokeStyle = colors.beeBlack;
                ctx.beginPath();
                if(isSideView){
                    ctx.moveTo(centerX, centerY - 12);
                    ctx.quadraticCurveTo(centerX + 5, centerY - 22, centerX + 8, centerY - 20);
                } else {
                    ctx.moveTo(centerX - 5, centerY - 12);
                    ctx.quadraticCurveTo(centerX - 10, centerY - 22, centerX - 4, centerY - 20);
                    ctx.moveTo(centerX + 5, centerY - 12);
                    ctx.quadraticCurveTo(centerX + 10, centerY - 22, centerX + 4, centerY - 20);
                }
                ctx.stroke();
                if(currentArtistType === 'student'){
                    ctx.fillStyle = colors.beretRed;
                    ctx.beginPath();
                    ctx.ellipse(isSideView ? centerX + 4 : centerX, centerY - 15, 12, 6, isSideView ? 0.2 : 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            }

            function drawAccessories(ctx, currentArtistType, x, y, bob, isSideView) {
                const centerX = x + frameSize / 2;
                const centerY = y + 55 + bob;
                ctx.strokeStyle = colors.outline;
                ctx.lineWidth = 1.5;
                switch(currentArtistType) {
                    case 'painter':
                        ctx.fillStyle = colors.paletteBrown;
                        ctx.beginPath();
                        ctx.ellipse(isSideView ? centerX + 20 : centerX - 20, centerY + 10, 8, 6, 0, 0, Math.PI*2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = colors.paintBlue; ctx.beginPath(); ctx.arc(isSideView ? centerX+18 : centerX-22, centerY+8, 1.5, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = colors.paintRed; ctx.beginPath(); ctx.arc(isSideView ? centerX+22 : centerX-18, centerY+8, 1.5, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = colors.paintGreen; ctx.beginPath(); ctx.arc(isSideView ? centerX+20 : centerX-20, centerY+12, 1.5, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = colors.beeBlack; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(isSideView ? centerX-20 : centerX+20, centerY+5); ctx.lineTo(isSideView ? centerX-28 : centerX+28, centerY); ctx.stroke();
                        break;
                    case 'woodworker':
                        ctx.lineWidth = 1;
                        ctx.fillStyle = colors.sawGray;
                        ctx.beginPath();
                        ctx.moveTo(isSideView ? centerX-20 : centerX+20, centerY);
                        ctx.lineTo(isSideView ? centerX-28 : centerX+28, centerY+10);
                        ctx.lineTo(isSideView ? centerX-18 : centerX+18, centerY+12);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = colors.woodBrown;
                        ctx.fillRect(isSideView ? centerX+15 : centerX-25, centerY+5, 10, 10);
                        ctx.strokeRect(isSideView ? centerX+15 : centerX-25, centerY+5, 10, 10);
                        break;
                    case 'sculptor':
                        ctx.lineWidth = 1;
                        ctx.fillStyle = colors.clayGray;
                        ctx.beginPath();
                        ctx.ellipse(isSideView ? centerX + 22 : centerX - 20, centerY + 8, 5, 6, 0, 0, Math.PI*2);
                        ctx.fill(); ctx.stroke();
                        ctx.fillStyle = colors.toolBrown;
                        ctx.fillRect(isSideView ? centerX - 25 : centerX + 15, centerY + 5, 12, 3);
                        ctx.strokeRect(isSideView ? centerX - 25 : centerX + 15, centerY + 5, 12, 3);
                        break;
                    case 'architect':
                        if (isSideView) {
                            ctx.fillStyle = colors.bagBrown; ctx.beginPath();
                            ctx.rect(centerX - 20, centerY - 5, 12, 14); ctx.fill(); ctx.stroke();
                            ctx.fillStyle = colors.paperWhite; ctx.strokeStyle = colors.beeBlack; ctx.lineWidth = 1;
                            ctx.beginPath(); ctx.rect(centerX - 18, centerY - 11, 4, 7); ctx.fill(); ctx.stroke();
                            ctx.beginPath(); ctx.rect(centerX - 13, centerY - 11, 4, 7); ctx.fill(); ctx.stroke();
                        } else {
                            ctx.strokeStyle = colors.bagBrown; ctx.lineWidth = 3;
                            ctx.beginPath(); ctx.moveTo(centerX - 12, centerY - 10); ctx.lineTo(centerX + 12, centerY + 8); ctx.stroke();
                            ctx.fillStyle = colors.bagBrown; ctx.lineWidth = 1.5; ctx.strokeStyle = colors.outline;
                            ctx.beginPath(); ctx.rect(centerX + 8, centerY, 14, 16); ctx.fill(); ctx.stroke();
                            ctx.fillStyle = colors.paperWhite; ctx.strokeStyle = colors.beeBlack; ctx.lineWidth = 1;
                            ctx.beginPath(); ctx.rect(centerX + 10, centerY - 6, 5, 8); ctx.fill(); ctx.stroke();
                            ctx.beginPath(); ctx.rect(centerX + 16, centerY - 6, 5, 8); ctx.fill(); ctx.stroke();
                        }
                        break;
                }
            }

            function drawBeeBody(ctx, currentArtistType, x, y, bob = 0, frame = 0, isSideView = false) {
                const centerX = x + frameSize / 2;
                const centerY = y + 55 + bob;
                ctx.strokeStyle = colors.outline;
                ctx.lineWidth = 1.5;
                const wingY = frame === 1 ? -5 : 0;
                ctx.fillStyle = colors.wingBlue;
                ctx.beginPath();
                if(isSideView){
                    ctx.ellipse(centerX - 12, centerY - 8 + wingY, 12, 7, -0.8, 0, Math.PI * 2);
                } else {
                    ctx.ellipse(centerX - 15, centerY - 8 + wingY, 12, 7, -0.8, 0, Math.PI * 2);
                    ctx.ellipse(centerX + 15, centerY - 8 + wingY, 12, 7, 0.8, 0, Math.PI * 2);
                }
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = colors.beeYellow;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 15, 18, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = colors.beeBlack;
                ctx.beginPath();
                ctx.rect(centerX - 15, centerY - 5, 30, 5);
                ctx.rect(centerX - 12, centerY + 5, 24, 4);
                ctx.fill();
                if(!isSideView) {
                    if(currentArtistType === 'woodworker') {
                        ctx.fillStyle = colors.apronBlue;
                        ctx.beginPath(); ctx.moveTo(centerX-8,centerY-10); ctx.lineTo(centerX+8,centerY-10); ctx.lineTo(centerX+10, centerY+14); ctx.lineTo(centerX-10, centerY+14); ctx.closePath(); ctx.fill(); ctx.stroke();
                    } else if (currentArtistType === 'sculptor') {
                        ctx.fillStyle = colors.smockGray;
                        ctx.beginPath(); ctx.moveTo(centerX - 10, centerY - 8); ctx.lineTo(centerX + 10, centerY - 8); ctx.lineTo(centerX + 12, centerY + 12); ctx.lineTo(centerX - 12, centerY + 12); ctx.closePath(); ctx.fill(); ctx.stroke();
                        ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        ctx.fillRect(centerX - 5, centerY, 2, 2); ctx.fillRect(centerX + 3, centerY + 5, 2, 2);
                    }
                }
                drawAccessories(ctx, currentArtistType, x, y, bob, isSideView);
            }

            function drawBeeLegs(ctx, x, y, frame = 1, bob = 0, isSideView = false) {
                const legY = y + 72 + bob;
                ctx.strokeStyle = colors.beeBlack;
                ctx.lineWidth = 2;
                let leftLegX = x + 38; let rightLegX = x + 52;
                let leftLegYOffset = 0; let rightLegYOffset = 0;
                if (isSideView) {
                    leftLegX = x + 42; rightLegX = x + 48;
                    if (frame === 1) { leftLegYOffset = 3; }
                    else if (frame === 2) { rightLegYOffset = 3; }
                } else {
                    if (frame === 2) { rightLegYOffset = 2; }
                    else if (frame === 3) { leftLegYOffset = 2; }
                }
                ctx.beginPath(); ctx.moveTo(rightLegX, legY); ctx.lineTo(rightLegX, legY + 8 + rightLegYOffset); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(leftLegX, legY); ctx.lineTo(leftLegX, legY + 8 + leftLegYOffset); ctx.stroke();
            }

            ctx.clearRect(0, 0, sheetSize, sheetSize);
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const x = col * frameSize;
                    const y = row * frameSize;
                    let bob = 0, frame = 1, isSideView = false;
                    if (row === 0) { // Idle
                        bob = (col === 1) ? 1 : 0;
                    } else if (row === 1) { // Walk Down
                        frame = (col % 2 === 0) ? (col === 0 ? 3 : 1) : 2;
                    } else if (row === 2) { // Walk Right
                        isSideView = true;
                        frame = (col % 2 === 0) ? (col === 0 ? 3 : 1) : 2;
                    }
                    drawBeeBody(ctx, artistType, x, y, bob, col, isSideView);
                    drawBeeLegs(ctx, x, y, frame, bob, isSideView);
                    drawBeeHead(ctx, x, y, isSideView, artistType);
                }
            }
        }

        let playerSpriteImage = null;
        let spriteSheetLoaded = false;
        function loadSpriteSheet() {
            const spriteCanvas = document.getElementById('spriteSheetCanvas');
            const spriteCtx = spriteCanvas.getContext('2d');
            generateOriginalSpriteSheet(spriteCanvas, spriteCtx);
            const dataURL = spriteCanvas.toDataURL('image/png');
            playerSpriteImage = new Image();
            playerSpriteImage.onload = () => { spriteSheetLoaded = true; };
            playerSpriteImage.onerror = () => {
                showMessage("Critical Error: Failed to load character sprites from generated image data.", null);
            };
            playerSpriteImage.src = dataURL;
        }

        function generateAndLoadCustomerSprite(customer) {
            const spriteCanvas = document.getElementById('spriteSheetCanvas');
            const spriteCtx = spriteCanvas.getContext('2d');
            const spriteType = customerTypes[customer.customerType]?.spriteType;

            if (spriteType) {
                generateBeeSpriteSheet(spriteCanvas, spriteCtx, spriteType);
                const dataURL = spriteCanvas.toDataURL('image/png');
                customer.spriteImage.src = dataURL;
                customer.spriteImage.onload = () => {
                    customer.spriteSheetLoaded = true;
                };
            }
        }


        /**
         * REFACTOR: Centralized function to draw any character sprite.
         * This reduces code duplication across all character draw functions.
         * @param {object} character - The character object (player, npc, customer).
         * @param {HTMLImageElement} image - The sprite sheet image to draw from.
         * @param {string} name - The name to display above the character.
         * @param {string} [filter=''] - A CSS filter to apply to the sprite (e.g., for different colors).
         * @param {boolean} [drawName=true] - Whether to draw the name text.
         */
        function drawCharacter(character, image, name, filter = '', drawName = true) {
            if (!image || !image.complete) return;

            // Determine animation state (idle or walking)
            let animState = 'idle';
            if (character.state && !['idle', 'transaction', 'ordering', 'takingItem', 'waitingAtCounter', 'placing', 'interacting'].includes(character.state)) {
                animState = 'walk';
            }

            const anim = animations[animState];
            if (!anim) return;

            // Determine animation row based on direction
            let animRow = 0;
            if (animState === 'walk') {
                animRow = (character.facing === 'left' || character.facing === 'right') ? 2 : 1;
            }

            const frameIndex = (animRow * anim.cols) + character.currentFrame;
            const col = frameIndex % anim.cols;
            const row = Math.floor(frameIndex / anim.cols);
            const sourceX = col * character.frameWidth;
            const sourceY = row * character.frameHeight;

            ctx.save();
            if (filter) {
                ctx.filter = filter;
            }

            let drawX = character.x - character.frameWidth / 2;
            if (character.facing === 'left') {
                ctx.scale(-1, 1);
                drawX = -character.x - character.frameWidth / 2;
            }

            ctx.drawImage(image, sourceX, sourceY, character.frameWidth, character.frameHeight, drawX, character.y - character.frameHeight, character.frameWidth, character.frameHeight);
            ctx.restore();

            if (drawName && name) {
                ctx.fillStyle = '#f7e7d8';
                ctx.font = '20px "Indie Flower", cursive';
                ctx.textAlign = 'center';
                ctx.fillText(name, character.x, character.y - character.frameHeight - 10);
            }
        }

        function drawPlayer() {
            drawCharacter(player, playerSpriteImage, "Shopkeep");
        }

        function drawStocker() {
            if (!unlocks.employees.stocker) return;
            drawCharacter(stocker, playerSpriteImage, "Stocker", 'hue-rotate(180deg) brightness(1.2)');
        }

        function drawCashier() {
            if (!unlocks.employees.cashier) return;
            drawCharacter(cashier, playerSpriteImage, "Cashier", 'sepia(0.8) saturate(3)');
        }

        function drawLoader() {
            if (!unlocks.employees.loader) return;
            drawCharacter(loader, playerSpriteImage, "Loader", 'hue-rotate(90deg) saturate(1.5)');
        }

        function drawManager() {
            if (!unlocks.employees.manager) return;
            drawCharacter(manager, playerSpriteImage, "Manager", 'hue-rotate(270deg) saturate(2)');
        }

        function drawSalesperson() {
            if (!unlocks.employees.salesperson) return;
            drawCharacter(salesperson, playerSpriteImage, "Sales", 'hue-rotate(320deg) saturate(2.5)');
        }

        function moveCharacterTowards(character, targetX, targetY, deltaTime) {
            const dx = targetX - character.x;
            const dy = targetY - character.y;
            const dist = Math.hypot(dx, dy);
            if (dist < 5) return true;
            const moveX = (dx / dist) * character.speed * (deltaTime / 1000);
            const moveY = (dy / dist) * character.speed * (deltaTime / 1000);
            character.x += moveX;
            character.y += moveY;
            if (Math.abs(dx) > Math.abs(dy)) {
                character.facing = moveX > 0 ? 'right' : 'left';
            }
            return false;
        }

        // --- START REFACTOR: Generic NPC Logic ---
        function updateCharacterAnimation(character, deltaTime) {
            const animState = (character.state && !['idle', 'transaction', 'ordering', 'takingItem', 'waitingAtCounter', 'placing', 'interacting'].includes(character.state)) ? 'walk' : 'idle';
            const anim = animations[animState];
            if (!anim) return;

            character.lastFrameTime += deltaTime;
            if (character.lastFrameTime >= character.animationSpeed) {
                character.currentFrame = (character.currentFrame + 1) % anim.frames;
                character.lastFrameTime = 0;
            }
        }

        function handlePreDayState(character, deltaTime) {
            if (!dayStarted) {
                if (Math.hypot(character.x - character.idleX, character.y - character.idleY) > 5) {
                    character.state = 'walk';
                    moveCharacterTowards(character, character.idleX, character.idleY, deltaTime);
                } else {
                    character.state = 'idle';
                }
                updateCharacterAnimation(character, deltaTime);
                return true; // Indicates the function should exit early
            }
            return false; // Continue with normal update logic
        }
        // --- END REFACTOR ---

        function updateStocker(deltaTime) {
            if (!unlocks.employees.stocker) return;

            if (stocker.onBreak) {
                const breakSpot = getBreakSpot('stocker');
                if (moveCharacterTowards(stocker, breakSpot.x, breakSpot.y, deltaTime)) {
                    stocker.state = 'idle';
                } else {
                    stocker.state = 'walk';
                }
                updateCharacterAnimation(stocker, deltaTime);
                return;
            }

            if (handlePreDayState(stocker, deltaTime)) return;

            updateCharacterAnimation(stocker, deltaTime);

            stocker.stateTimer -= deltaTime;
            switch(stocker.state) {
                case 'idle':
                    if (stocker.stateTimer <= 0) {
                        const task = findRestockingTask();
                        if (task) {
                            stocker.task = task;
                            stocker.state = 'fetching';
                        } else {
                           stocker.stateTimer = 3000;
                           if(Math.hypot(stocker.x - stocker.idleX, stocker.y - stocker.idleY) > 5) {
                               stocker.task = { target: {x: stocker.idleX, y: stocker.idleY} };
                           } else {
                               stocker.task = null;
                           }
                        }
                    }
                    if(stocker.task && stocker.task.target) {
                        moveCharacterTowards(stocker, stocker.task.target.x, stocker.task.target.y, deltaTime);
                    }
                    break;
                case 'fetching':
                    if (moveCharacterTowards(stocker, stocker.task.target.x, stocker.task.target.y, deltaTime)) {
                        const itemToTake = stocker.task.item;
                        const cell = storageCells.find(c => c.allowedItems.includes(itemToTake));
                        while(stocker.basket.length < STOCKER_BASKET_SIZE && cell && cell.items[itemToTake] > 0) {
                            stocker.basket.push(itemToTake);
                            cell.items[itemToTake]--;
                        }
                        stocker.state = 'stocking';
                        stocker.task = null;
                    }
                    break;
                case 'stocking':
                    if (!stocker.task) {
                        if (stocker.basket.length === 0) {
                            stocker.state = 'idle';
                            stocker.task = { target: {x: stocker.idleX, y: stocker.idleY} };
                            break;
                        }
                        const itemToStock = stocker.basket[0];
                        const targetShelf = findShelfForStocking(itemToStock);
                        if (targetShelf) {
                            stocker.task = { action: 'place', item: itemToStock, shelf: targetShelf, target: {x: targetShelf.rect.x + targetShelf.rect.w / 2, y: targetShelf.rect.y + targetShelf.rect.h + 10} };
                        } else {
                            stocker.basket.shift();
                        }
                    }
                    if (stocker.task && moveCharacterTowards(stocker, stocker.task.target.x, stocker.task.target.y, deltaTime)) {
                        const shelf = stocker.task.shelf;
                        const itemToStock = stocker.task.item;

                        let slot = shelf.items.find(s => s.assignedItem === itemToStock && s.quantity < MAX_SHELF_STACK);
                        if (!slot) {
                            slot = shelf.items.find(s => s.assignedItem === null);
                        }

                        if (slot) {
                            const itemIndexInBasket = stocker.basket.indexOf(itemToStock);
                            if(itemIndexInBasket > -1) {
                                if(slot.assignedItem === null) {
                                    slot.assignedItem = itemToStock;
                                }
                                stocker.basket.splice(itemIndexInBasket, 1);
                                slot.quantity++;
                            }
                        }
                        stocker.task = null;
                    }
                    break;
            }
        }

        function updateCashier(deltaTime) {
            if (!unlocks.employees.cashier) return;

            if (cashier.onBreak) {
                const breakSpot = getBreakSpot('cashier');
                if (moveCharacterTowards(cashier, breakSpot.x, breakSpot.y, deltaTime)) {
                    cashier.state = 'idle';
                } else {
                    cashier.state = 'walk';
                }
                updateCharacterAnimation(cashier, deltaTime);
                return;
            }

            if (handlePreDayState(cashier, deltaTime)) return;

            updateCharacterAnimation(cashier, deltaTime);

            cashier.stateTimer -= deltaTime;
            switch (cashier.state) {
                case 'idle':
                    const customerToServe = customers
                        .filter(c => c.state === 'waitingAtCounter' && !c.isServed)
                        .sort((a, b) => a.x - b.x)[0];
                    if (customerToServe) {
                        cashier.task = {
                            action: 'serve',
                            customerId: customerToServe.id,
                            target: { x: customerToServe.x - 30, y: customerToServe.y - 100 }
                        };
                        cashier.state = 'serving';
                    }
                    break;
                case 'serving':
                    if(cashier.task && moveCharacterTowards(cashier, cashier.task.target.x, cashier.task.target.y, deltaTime)) {
                        cashier.state = 'transaction';
                        cashier.stateTimer = 1500;
                    }
                    break;
                case 'transaction':
                    if(cashier.stateTimer <= 0) {
                        if(cashier.task) {
                            completeTransaction(cashier.task.customerId);
                        }
                        cashier.task = { target: {x: cashier.idleX, y: cashier.idleY } };
                        cashier.state = 'returning';
                    }
                    break;
                case 'returning':
                    if(cashier.task && moveCharacterTowards(cashier, cashier.task.target.x, cashier.task.target.y, deltaTime)) {
                        cashier.state = 'idle';
                        cashier.task = null;
                    }
                    break;
            }
        }

        function updateLoader(deltaTime) {
             if (!unlocks.employees.loader) return;

            if (loader.onBreak) {
                const breakSpot = getBreakSpot('loader');
                if (moveCharacterTowards(loader, breakSpot.x, breakSpot.y, deltaTime)) {
                    loader.state = 'idle';
                } else {
                    loader.state = 'walk';
                }
                updateCharacterAnimation(loader, deltaTime);
                return;
            }

             if (handlePreDayState(loader, deltaTime)) return;

            updateCharacterAnimation(loader, deltaTime);
            loader.stateTimer -= deltaTime;

            switch(loader.state) {
                case 'idle':
                    if (loader.stateTimer <= 0) {
                        if (loadingDockPackages.length > 0) {
                            loader.state = 'fetching_dock';
                            const firstPackageX = 10 + PACKAGE_WIDTH / 2;
                            loader.task = { target: { x: firstPackageX, y: loadingDock.y - 30 } };
                        } else {
                            loader.stateTimer = 2000; // Check again in 2 seconds
                             if(Math.hypot(loader.x - loader.idleX, loader.y - loader.idleY) > 5) {
                                 loader.task = { target: {x: loader.idleX, y: loader.idleY} };
                             } else {
                                 loader.task = null;
                             }
                        }
                    }
                     if(loader.task && loader.task.target) {
                         moveCharacterTowards(loader, loader.task.target.x, loader.task.target.y, deltaTime);
                    }
                    break;
                case 'fetching_dock':
                    if (moveCharacterTowards(loader, loader.task.target.x, loader.task.target.y, deltaTime)) {
                        if (loadingDockPackages.length > 0) {
                            const firstPackage = loadingDockPackages[0];
                            while(loader.basket.length < LOADER_BASKET_SIZE && firstPackage.quantity > 0) {
                                loader.basket.push(firstPackage.itemName);
                                firstPackage.quantity--;
                            }
                             if (firstPackage.quantity <= 0) {
                                 loadingDockPackages.shift();
                            }
                        }
                        loader.state = 'delivering';
                        loader.task = null;
                    }
                    break;
                case 'delivering':
                     if (!loader.task) {
                        if (loader.basket.length === 0) {
                            loader.state = 'idle';
                            loader.task = { target: {x: loader.idleX, y: loader.idleY} };
                            break;
                        }
                        const itemToDeliver = loader.basket[0];
                        const targetCell = storageCells.find(c => c.allowedItems.includes(itemToDeliver));
                         if(targetCell) {
                             const currentFill = Object.values(targetCell.items).reduce((a, b) => a + b, 0);
                             if (currentFill < targetCell.capacity) {
                                 loader.task = { target: { x: targetCell.rect.x + targetCell.rect.w / 2, y: targetCell.rect.y + targetCell.rect.h + 20 }, item: itemToDeliver, cell: targetCell };
                             } else {
                                 // Cell is full, wait and try again
                                 loader.stateTimer = 3000;
                                 loader.task = null;
                             }
                         } else {
                            console.error(`No storage cell found for ${itemToDeliver}`);
                            loader.basket.shift(); // discard item if no home
                         }
                        }
                         if (loader.task && moveCharacterTowards(loader, loader.task.target.x, loader.task.target.y, deltaTime)) {
                         const deliveredItem = loader.basket.shift();
                         const cell = loader.task.cell;
                         if (!cell.items[deliveredItem]) {
                             cell.items[deliveredItem] = 0;
                         }
                         cell.items[deliveredItem]++;
                         loader.task = null;
                        }
                    break;

            }
        }

        function getTotalStock(itemName) {
            let total = 0;
            // Check storage cells
            storageCells.forEach(cell => {
                if (cell.items && cell.items[itemName]) {
                    total += cell.items[itemName];
                }
            });
            // Check loading dock packages
            loadingDockPackages.forEach(pkg => {
                if (pkg.itemName === itemName) {
                    total += pkg.quantity;
                }
            });
            // Check shelves
            shelves.forEach(shelf => {
                shelf.items.forEach(slot => {
                    if (slot.assignedItem === itemName) {
                        total += slot.quantity;
                    }
                });
            });
            return total;
        }

        function getBackroomStock(itemName) {
            let total = 0;
            // Check storage cells
            storageCells.forEach(cell => {
                if (cell.items && cell.items[itemName]) {
                    total += cell.items[itemName];
                }
            });
            // Check loading dock packages
            loadingDockPackages.forEach(pkg => {
                if (pkg.itemName === itemName) {
                    total += pkg.quantity;
                }
            });
            return total;
        }

        function updateManager(deltaTime) {
             if (!unlocks.employees.manager) return;

            if (manager.onBreak) {
                const breakSpot = getBreakSpot('manager');
                if (moveCharacterTowards(manager, breakSpot.x, breakSpot.y, deltaTime)) {
                    manager.state = 'idle';
                } else {
                    manager.state = 'walk';
                }
                updateCharacterAnimation(manager, deltaTime);
                return;
            }

             if (handlePreDayState(manager, deltaTime)) return;

            const currentQuarter = Math.floor(((DAY_DURATION - dayTimer) / DAY_DURATION) * 4);
            if (currentQuarter > manager.lastOrderQuarter) {
                manager.canOrder = true;
            }

            updateCharacterAnimation(manager, deltaTime);
            manager.stateTimer -= deltaTime;

            switch(manager.state) {
                case 'idle':
                    if (manager.stateTimer <= 0) {
                        const MAX_DOCK_PACKAGES = 5;

                        // --- Morning Prep Logic ---
                        if (dayPhase === 'opening' && manager.canOrder && !manager.hasPlacedMorningOrder) {
                            const shelfDemand = {};
                            const shelfStock = {};
                            shelves.forEach(shelf => {
                                shelf.items.forEach(slot => {
                                    if (slot.assignedItem) {
                                        const itemName = slot.assignedItem;
                                        shelfDemand[itemName] = (shelfDemand[itemName] || 0) + MAX_SHELF_STACK;
                                        shelfStock[itemName] = (shelfStock[itemName] || 0) + slot.quantity;
                                    }
                                });
                            });

                            const shoppingList = [];
                            for (const itemName in shelfDemand) {
                                const neededToFillShelves = shelfDemand[itemName] - shelfStock[itemName];
                                const backroomStock = getBackroomStock(itemName);
                                const neededFromSupplier = neededToFillShelves - backroomStock;
                                if (neededFromSupplier > 0) {
                                    shoppingList.push({ itemName, quantity: neededFromSupplier });
                                }
                            }

                            if (shoppingList.length > 0) {
                                shoppingList.sort((a, b) => (itemPopularity[b.itemName] || 0) - (itemPopularity[a.itemName] || 0));
                                const finalOrderList = [];
                                let totalCost = 0;
                                const availableCash = cash - 30;

                                for (const orderItem of shoppingList) {
                                    const itemCost = parseFloat((items[orderItem.itemName].cost * 0.75).toFixed(2)) * orderItem.quantity;
                                    if (totalCost + itemCost <= availableCash) {
                                        totalCost += itemCost;
                                        finalOrderList.push(orderItem);
                                    }
                                }

                                let packagesFromOrder = 0;
                                finalOrderList.forEach(orderItem => {
                                    packagesFromOrder += Math.ceil(orderItem.quantity / MAX_PACKAGE_SIZE);
                                });

                                if (finalOrderList.length > 0 && loadingDockPackages.length + packagesFromOrder <= MAX_DOCK_PACKAGES) {
                                    manager.task = {
                                        action: 'order_bulk',
                                        items: finalOrderList,
                                        totalCost: totalCost,
                                        target: { x: managersOffice.x + managersOffice.w / 2, y: managersOffice.y + managersOffice.h + 10 }
                                    };
                                    manager.state = 'going_to_office';
                                    manager.hasPlacedMorningOrder = true;
                                    manager.canOrder = false;
                                    manager.lastOrderQuarter = 0;
                                    break; // Exit switch case to process new state
                                }
                            }
                        }

                        // --- Urgent Order Logic (Any Time) ---
                        let urgentOrderItem = null;
                        let requiredQuantity = 0;
                        const waitingCustomers = customers.filter(c => c.isWaitingForRestock);
                        if (waitingCustomers.length > 0) {
                            const customerDemands = {};
                            for (const customer of waitingCustomers) {
                                const waitingOnItem = customer.requestedItems[customer.currentItemIndex];
                                if (waitingOnItem && getTotalStock(waitingOnItem) === 0) {
                                    const isItemUnlocked = storageCells.some(cell => unlocks.storage[storageCells.indexOf(cell)] && cell.allowedItems.includes(waitingOnItem));
                                    if (isItemUnlocked) {
                                        customerDemands[waitingOnItem] = (customerDemands[waitingOnItem] || 0) + 1;
                                    }
                                }
                            }
                            let maxDemand = 0;
                            for (const item in customerDemands) {
                                if (customerDemands[item] > maxDemand) {
                                    maxDemand = customerDemands[item];
                                    urgentOrderItem = item;
                                    requiredQuantity = customerDemands[item];
                                }
                            }
                        }

                        if (urgentOrderItem) {
                            const quantityToOrder = requiredQuantity;
                            const packagesFromOrder = Math.ceil(quantityToOrder / MAX_PACKAGE_SIZE);
                            if (loadingDockPackages.length + packagesFromOrder <= MAX_DOCK_PACKAGES) {
                                manager.task = {
                                    action: 'order',
                                    item: urgentOrderItem,
                                    isUrgent: true,
                                    requiredQuantity: requiredQuantity,
                                    target: { x: managersOffice.x + managersOffice.w / 2, y: managersOffice.y + managersOffice.h + 10 }
                                };
                                manager.state = 'going_to_office';
                                manager.stateTimer = 1000;
                                break;
                            }
                        }

                        // --- Evening Low-Stock Check ---
                        if (manager.canOrder && dayPhase === 'closing') {
                            const lowStockItems = Object.keys(items).filter(item => {
                                const stock = getTotalStock(item);
                                return stock < 5;
                            });

                            if (lowStockItems.length > 0) {
                                lowStockItems.sort((a, b) => (itemPopularity[b] || 0) - (itemPopularity[a] || 0));
                                const mostPopularLowItem = lowStockItems[0];
                                const quantityToOrder = 10;
                                const packagesFromOrder = Math.ceil(quantityToOrder / MAX_PACKAGE_SIZE);

                                if (loadingDockPackages.length + packagesFromOrder <= MAX_DOCK_PACKAGES) {
                                    manager.task = {
                                        action: 'order',
                                        item: mostPopularLowItem,
                                        isUrgent: false,
                                        target: { x: managersOffice.x + managersOffice.w / 2, y: managersOffice.y + managersOffice.h + 10 }
                                    };
                                    manager.state = 'going_to_office';
                                } else {
                                    manager.stateTimer = 10000;
                                    if(Math.hypot(manager.x - manager.idleX, manager.y - manager.idleY) > 5) {
                                         manager.task = { target: {x: manager.idleX, y: manager.idleY} };
                                     } else {
                                         manager.task = null;
                                     }
                                }
                            } else {
                                 manager.stateTimer = 10000;
                                if(Math.hypot(manager.x - manager.idleX, manager.y - manager.idleY) > 5) {
                                     manager.task = { target: {x: manager.idleX, y: manager.idleY} };
                                 } else {
                                     manager.task = null;
                                 }
                            }
                        } else {
                             manager.stateTimer = 5000;
                        }
                    }

                     if(manager.task && manager.task.target) {
                         moveCharacterTowards(manager, manager.task.target.x, manager.task.target.y, deltaTime);
                    }
                    break;
                case 'going_to_office':
                     if (moveCharacterTowards(manager, manager.task.target.x, manager.task.target.y, deltaTime)) {
                        manager.state = 'ordering';
                        manager.stateTimer = 3000; // Time to "place order"
                    }
                    break;
                case 'ordering':
                    if(manager.stateTimer <= 0) {
                        const orderTask = manager.task;

                        if (orderTask.action === 'order_bulk') {
                            cash -= orderTask.totalCost;
                            updateUI();
                            orderTask.items.forEach(orderItem => {
                                let remainingQuantity = orderItem.quantity;
                                while (remainingQuantity > 0) {
                                    const quantityForPackage = Math.min(remainingQuantity, MAX_PACKAGE_SIZE);
                                    loadingDockPackages.push({ itemName: orderItem.itemName, quantity: quantityForPackage });
                                    remainingQuantity -= quantityForPackage;
                                }
                            });
                            spawnFloatingText(`Bulk Order Placed! (-$${orderTask.totalCost.toFixed(2)})`, manager.x, manager.y - 90, '#3b82f6');
                        } else {
                            // Single item order logic
                            const itemToOrder = orderTask.item;
                            const quantityToOrder = orderTask.isUrgent ? orderTask.requiredQuantity : 10;
                            const restockPrice = parseFloat((items[itemToOrder].cost * 0.75).toFixed(2));
                            const totalCost = restockPrice * quantityToOrder;

                            if (cash - totalCost < 30) {
                                spawnFloatingText(`Can't afford ${itemToOrder}!`, manager.x, manager.y - 90, '#ef4444');
                                manager.state = 'idle';
                                manager.stateTimer = 15000; // Wait longer before trying again
                                manager.task = { target: {x: manager.idleX, y: manager.idleY} };
                                break;
                            }

                            cash -= totalCost;
                            updateUI();

                            let remainingQuantity = quantityToOrder;
                            while (remainingQuantity > 0) {
                                const quantityForPackage = Math.min(remainingQuantity, MAX_PACKAGE_SIZE);
                                loadingDockPackages.push({itemName: itemToOrder, quantity: quantityForPackage});
                                remainingQuantity -= quantityForPackage;
                            }
                             spawnFloatingText(`${itemToOrder} Ordered! (-$${totalCost.toFixed(2)})`, manager.x, manager.y - 90, '#3b82f6');
                        }

                        manager.state = 'idle';
                        manager.stateTimer = 5000;
                        manager.task = { target: {x: manager.idleX, y: manager.idleY} };

                        if (orderTask.action !== 'order_bulk' && !orderTask.isUrgent) {
                            manager.canOrder = false;
                            manager.lastOrderQuarter = currentQuarter;
                        }
                    }
                    break;
            }
        }

        function updateSalesperson(deltaTime) {
            if (!unlocks.employees.salesperson) return;

            if (salesperson.onBreak) {
                const breakSpot = getBreakSpot('salesperson');
                if (moveCharacterTowards(salesperson, breakSpot.x, breakSpot.y, deltaTime)) {
                    salesperson.state = 'idle';
                } else {
                    salesperson.state = 'walk';
                }
                updateCharacterAnimation(salesperson, deltaTime);
                return;
            }

            if (handlePreDayState(salesperson, deltaTime)) return;

            updateCharacterAnimation(salesperson, deltaTime);
            salesperson.stateTimer -= deltaTime;

            switch (salesperson.state) {
                case 'idle':
                    if (salesperson.stateTimer <= 0) {
                        // --- PRIORITY 1: Help Starred Customers ---
                        const starredCustomer = customers.find(c => c.profile.isStarred && (c.behaviorType === 'needsInteraction' && !c.isInteractedWith || c.behaviorType === 'needsAssistance' && !c.needsAssistanceFulfilled) && !c.leaving);
                        if (starredCustomer) {
                            if (starredCustomer.behaviorType === 'needsInteraction') {
                                salesperson.state = 'goingToInteract';
                                salesperson.task = { customer: starredCustomer, target: { x: starredCustomer.x + 50, y: starredCustomer.y } };
                            } else { // needsAssistance
                                salesperson.state = 'assistingCustomer';
                                salesperson.task = {
                                    customer: starredCustomer,
                                    currentItemIndex: 0,
                                    missingItems: []
                                };
                            }
                            return;
                        }

                        // --- Original Logic ---
                        const customerToAssist = customers.find(c => c.behaviorType === 'needsAssistance' && !c.needsAssistanceFulfilled && !c.leaving);
                        if (customerToAssist) {
                            salesperson.state = 'assistingCustomer';
                            salesperson.task = {
                                customer: customerToAssist,
                                currentItemIndex: 0,
                                missingItems: [] // REFACTOR: Initialize missing items list
                            };
                            return;
                        }

                        const customerToInteract = customers.find(c => c.behaviorType === 'needsInteraction' && !c.isInteractedWith && !c.leaving);
                        if (customerToInteract) {
                            salesperson.state = 'goingToInteract';
                            salesperson.task = { customer: customerToInteract, target: { x: customerToInteract.x + 50, y: customerToInteract.y } };
                            return;
                        }

                        salesperson.state = 'wandering';
                        salesperson.stateTimer = Math.random() * 3000 + 2000;
                        if (shelves && shelves.length > 0) {
                            const randomShelf = shelves[Math.floor(Math.random() * shelves.length)];
                            salesperson.task = { target: { x: randomShelf.rect.x + randomShelf.rect.w / 2, y: randomShelf.rect.y + randomShelf.rect.h + 20 } };
                        } else {
                            salesperson.state = 'idle';
                            salesperson.stateTimer = 2000;
                            salesperson.task = null;
                        }
                    }
                    break;

                case 'wandering':
                    if (!salesperson.task || moveCharacterTowards(salesperson, salesperson.task.target.x, salesperson.task.target.y, deltaTime)) {
                        salesperson.state = 'idle';
                        salesperson.task = null;
                        salesperson.stateTimer = 1000;
                    }
                    break;

                case 'goingToInteract':
                    if (!salesperson.task.customer || salesperson.task.customer.leaving) {
                         salesperson.state = 'idle';
                         salesperson.task = null;
                         return;
                    }
                    if (moveCharacterTowards(salesperson, salesperson.task.target.x, salesperson.task.target.y, deltaTime)) {
                        salesperson.state = 'interacting';
                        salesperson.stateTimer = 1000;
                    }
                    break;

                case 'interacting':
                    if (salesperson.stateTimer <= 0) {
                        const customer = salesperson.task.customer;
                        if (customer && !customer.leaving) {
                            if (customer.waitTimer > 60) { // Check for 60 seconds
                                // The salesperson can also convince waiting customers
                                if (customer.order.length > 0) {
                                    customer.discount = 0.25;
                                    customer.state = 'queuing';
                                    customer.request = "Okay, you've convinced me.";
                                    spawnFloatingText("Deal Made!", salesperson.x, salesperson.y - 90, '#3b82f6');
                                } else {
                                    // Same 50/50 logic as player
                                    if (Math.random() < 0.5) {
                                        const allStockedItems = [];
                                        shelves.forEach(shelf => shelf.items.forEach(slot => {
                                            if (slot.assignedItem && slot.quantity > 0) allStockedItems.push(slot.assignedItem);
                                        }));
                                        if (allStockedItems.length > 0) {
                                            const randomItem = allStockedItems[Math.floor(Math.random() * allStockedItems.length)];
                                            customer.order.push(randomItem);
                                            customer.profile.patience -= 10;
                                            customer.patience = customer.profile.patience; // Sync instance
                                            customer.state = 'queuing';
                                            customer.request = `Alright, you've convinced me. I'll take the ${randomItem}.`;
                                            spawnFloatingText("Convinced!", salesperson.x, salesperson.y - 90, '#f59e0b');
                                        } else {
                                            customer.profile.patience -= 30;
                                            customer.patience = customer.profile.patience; // Sync instance
                                            logCustomerToSalesReport(customer);
                                            customer.state = 'leaving';
                                            customer.request = "Your staff couldn't find anything either!";
                                            spawnFloatingText("Leaving Angry!", salesperson.x, salesperson.y - 90, '#ef4444');
                                        }
                                    } else {
                                        customer.profile.patience -= 30;
                                        customer.patience = customer.profile.patience; // Sync instance
                                        logCustomerToSalesReport(customer);
                                        customer.state = 'leaving';
                                        customer.request = "I'm tired of waiting, even with your help.";
                                        spawnFloatingText("Leaving Angry!", salesperson.x, salesperson.y - 90, '#ef4444');
                                    }
                                }
                            } else {
                                // Original interaction logic
                                customer.isInteractedWith = true;
                                spawnFloatingText("Let me help!", salesperson.x, salesperson.y - 90, '#3b82f6');
                            }
                        }
                        salesperson.state = 'idle';
                        salesperson.task = null;
                        salesperson.stateTimer = 2000;
                    }
                    break;

                case 'assistingCustomer': // This state now just initializes the collecting state
                    salesperson.state = 'collectingItem';
                    break;
                case 'collectingItem':
                    {
                        const task = salesperson.task;
                        if (!task.customer || task.customer.leaving) {
                            salesperson.state = 'idle';
                            salesperson.task = null;
                            return;
                        }

                        // REFACTOR START: Logic to check all items before reporting.
                        if (task.currentItemIndex >= task.customer.requestedItems.length) {
                            // Finished checking all items.
                            if (task.missingItems.length > 0) {
                                salesperson.state = 'reportingToPlayer';
                                const missingItemsString = task.missingItems.join(', ');
                                salesperson.task.message = `We're out of ${missingItemsString} for ${task.customer.name}!`;
                            } else {
                                // All items collected, go deliver them.
                                salesperson.state = 'deliveringItems';
                                salesperson.task.target = { x: task.customer.x - 50, y: task.customer.y };
                            }
                            return; // Exit switch to process new state in next frame
                        }
                        // REFACTOR END

                        const itemToCollect = task.customer.requestedItems[task.currentItemIndex];

                        const targetShelf = shelves.find(s => s.items.some(i => i && i.assignedItem === itemToCollect && i.quantity > 0));

                        if (targetShelf) {
                            const targetPos = { x: targetShelf.rect.x + targetShelf.rect.w / 2, y: targetShelf.rect.y + targetShelf.rect.h + 20 };
                            if (moveCharacterTowards(salesperson, targetPos.x, targetPos.y, deltaTime)) {
                                const slot = targetShelf.items.find(i => i && i.assignedItem === itemToCollect && i.quantity > 0);
                                if (slot) {
                                    slot.quantity--;
                                    salesperson.basket.push(itemToCollect);
                                    task.currentItemIndex++; // Move to next item
                                }
                            }
                            return;
                        }

                        const targetCell = storageCells.find(c => c.allowedItems.includes(itemToCollect) && c.items[itemToCollect] > 0);
                        if (targetCell) {
                            salesperson.state = 'fetchingFromStorage';
                            salesperson.task.target = {
                                x: targetCell.rect.x + targetCell.rect.w / 2,
                                y: targetCell.rect.y + targetCell.rect.h + 20,
                                cell: targetCell,
                                item: itemToCollect
                            };
                            return;
                        }

                        // REFACTOR: Item is not found anywhere. Add to missing list and check next item.
                        task.missingItems.push(itemToCollect);
                        task.currentItemIndex++;
                    }
                    break;

                case 'fetchingFromStorage':
                    if (moveCharacterTowards(salesperson, salesperson.task.target.x, salesperson.task.target.y, deltaTime)) {
                        const cell = salesperson.task.target.cell;
                        const item = salesperson.task.target.item;
                        if (cell && item && cell.items[item] > 0) {
                            cell.items[item]--;
                            salesperson.basket.push(item);
                            salesperson.task.currentItemIndex++;
                        }
                        salesperson.state = 'collectingItem'; // Go back to check for the next item
                        salesperson.task.target = null;
                    }
                    break;
                case 'reportingToPlayer':
                    salesperson.task.target = { x: player.x, y: player.y + 50 };

                    if (moveCharacterTowards(salesperson, salesperson.task.target.x, salesperson.task.target.y, deltaTime)) {
                        spawnFloatingText(salesperson.task.message, salesperson.x, salesperson.y - 90, '#8b5cf6');

                        // After reporting, go deliver whatever was found
                        salesperson.state = 'deliveringItems';
                        salesperson.task.target = { x: salesperson.task.customer.x - 50, y: salesperson.task.customer.y };
                        salesperson.task.message = null;
                    }
                    break;
                case 'deliveringItems':
                     if (!salesperson.task.customer || salesperson.task.customer.leaving) {
                         salesperson.state = 'idle';
                         salesperson.task = null;
                         return;
                    }
                    if (moveCharacterTowards(salesperson, salesperson.task.target.x, salesperson.task.target.y, deltaTime)) {
                        if(salesperson.basket.length > 0) {
                            salesperson.task.customer.order.push(...salesperson.basket);
                            salesperson.basket = [];
                            spawnFloatingText("Here's what I found!", salesperson.x, salesperson.y - 90, '#22c55e');
                        }
                        salesperson.task.customer.waitTimer = 0; // Reset wait timer
                        salesperson.task.customer.needsAssistanceFulfilled = true;
                        salesperson.task.customer.state = 'queuing';
                        salesperson.task.customer.request = "Thank you so much for your help!";


                        salesperson.state = 'idle';
                        salesperson.task = null;
                        salesperson.stateTimer = 3000;
                    }
                    break;
            }
        }


        function findShelfForStocking(itemName) {
            let targetShelf = shelves.find((s, i) => unlocks.shelves[i] && s.items.some(i => i && i.assignedItem === itemName && i.quantity < MAX_SHELF_STACK));
             if (!targetShelf) {
                 targetShelf = shelves.find((s, i) => unlocks.shelves[i] && s.items.some(i => i.assignedItem === null));
            }
            return targetShelf;
        }

        function findRestockingTask() {
             // --- REFACTOR START: Deadlock Prevention ---
            const fullCell = storageCells.find(c => {
                if (!c.items) return false;
                const currentFill = Object.values(c.items).reduce((a, b) => a + b, 0);
                return currentFill >= c.capacity;
            });

            if (fullCell && loader.state === 'idle' && loadingDockPackages.length > 0) {
                // A cell is full and the loader is waiting. Prioritize emptying that cell.
                for (const item in fullCell.items) {
                    if (fullCell.items[item] > 0) {
                        const shelfWithSpace = findShelfForStocking(item);
                        if (shelfWithSpace) {
                            // Create a high-priority task to move this item out of the full cell.
                            return {
                                action: 'fetch',
                                item: item,
                                target: { x: fullCell.rect.x + fullCell.rect.w / 2, y: fullCell.rect.y + fullCell.rect.h + 10 },
                                priority: 'deadlock_break'
                            };
                        }
                    }
                }
            }
            // --- REFACTOR END ---


            let neededItems = [];
            // Prioritize assigned but understocked shelves
            for(let i = 0; i < shelves.length; i++) {
                if (unlocks.shelves[i]) {
                    for(const slot of shelves[i].items) {
                        const storageCell = storageCells.find(c => c.allowedItems.includes(slot.assignedItem));
                        const stock = storageCell ? storageCell.items[slot.assignedItem] || 0 : 0;

                        if (slot.assignedItem && slot.quantity < MAX_SHELF_STACK && stock > 0) {
                             if(!neededItems.includes(slot.assignedItem)) neededItems.push(slot.assignedItem);
                        }
                    }
                }
            }
            // Then check for unassigned items that have stock
            for(const item in inventory){
                const stock = Object.values(storageCells.find(c => c.allowedItems.includes(item))?.items || {}).reduce((a,b)=>a+b, 0) || 0;
                if (stock > 0) {
                    const isAssigned = shelves.some(s => s.items.some(i => i.assignedItem === item));
                    if(!isAssigned && !neededItems.includes(item)) {
                        const hasEmptySlot = shelves.some((s, i) => unlocks.shelves[i] && s.items.some(i => i.assignedItem === null));
                        if (hasEmptySlot) {
                            neededItems.push(item);
                        }
                    }
                }
            }

            if (neededItems.length > 0) {
                const itemToFetch = neededItems[0];
                const storageCell = storageCells.find((c,i) => unlocks.storage[i] && c.allowedItems.includes(itemToFetch));
                if (storageCell) {
                    return {
                        action: 'fetch',
                        item: itemToFetch,
                        target: { x: storageCell.rect.x + storageCell.rect.w / 2, y: storageCell.rect.y + storageCell.rect.h + 10 }
                    };
                }
            }
            return null;
        }

        function updatePlayer(deltaTime) {
            let dx = 0, dy = 0;
            if (keys['KeyA'] || keys['ArrowLeft']) dx -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) dx += 1;
            if (keys['KeyW'] || keys['ArrowUp']) dy -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) dy += 1;

            if (dx !== 0 || dy !== 0) {
                // Keyboard movement overrides click-to-move
                player.targetX = null;
                player.targetY = null;

                const newX = player.x + dx * player.speed * (deltaTime / 1000);
                const newY = player.y + dy * player.speed * (deltaTime / 1000);
                player.y = newY;
                player.x = newX;

                player.state = 'walk';
                if (dx < 0) player.facing = 'left';
                if (dx > 0) player.facing = 'right';

            } else if (player.targetX !== null && player.targetY !== null) {
                // Click-to-move logic
                const targetDx = player.targetX - player.x;
                const targetDy = player.targetY - player.y;
                const dist = Math.hypot(targetDx, targetDy);

                if (dist < 5) { // Threshold to stop
                    player.targetX = null;
                    player.targetY = null;
                    player.state = 'idle';
                } else {
                    const moveX = (targetDx / dist) * player.speed * (deltaTime / 1000);
                    const moveY = (targetDy / dist) * player.speed * (deltaTime / 1000);
                    player.x += moveX;
                    player.y += moveY;

                    if (Math.abs(targetDx) > Math.abs(targetDy)) {
                        player.facing = moveX > 0 ? 'right' : 'left';
                    }
                    player.state = 'walk';
                }
            } else {
                player.state = 'idle';
            }

            const worldWidth = canvas.width + managersOffice.w;
            player.x = Math.max(player.frameWidth / 2, Math.min(worldWidth - player.frameWidth / 2, player.x));
            player.y = Math.max(player.frameHeight, Math.min(canvas.height, player.y));


            // Camera control logic
            const officeThreshold = officeWidth + 50; // 50px into the store
            if (player.x < officeThreshold && cameraState !== 'office') {
                cameraState = 'office';
                targetCameraX = 0;
            } else if (player.x >= officeThreshold && cameraState !== 'store') {
                cameraState = 'store';
                targetCameraX = -officeWidth;
            }

            updateCharacterAnimation(player, deltaTime);
        }

        function spawnFloatingText(text, x, y, color = 'green', duration = 1500) {
            floatingTexts.push({ text, x, y, color, duration, life: duration });
        }

        function updateAndDrawFloatingTexts(deltaTime) {
            floatingTexts.forEach(text => {
                text.life -= deltaTime;
                text.y -= 20 * (deltaTime / 1000); // Float up
                const opacity = Math.max(0, text.life / text.duration);

                ctx.save();
                ctx.globalAlpha = opacity;
                ctx.fillStyle = text.color;
                ctx.font = 'bold 24px "Patrick Hand", cursive';
                ctx.textAlign = 'center';
                ctx.fillText(text.text, text.x, text.y);
                ctx.restore();
            });
            floatingTexts = floatingTexts.filter(t => t.life > 0);
        }

        function drawPieClock() {
            const centerX = pieClockCanvas.width / 2;
            const centerY = pieClockCanvas.height / 2;
            const radius = Math.min(centerX, centerY) - 2;
            pieClockCtx.clearRect(0, 0, pieClockCanvas.width, pieClockCanvas.height);

            const startAngle = -Math.PI / 2;
            const openingAngle = (OPENING_DURATION / DAY_DURATION) * 2 * Math.PI;
            const openAngle = (OPEN_DURATION / DAY_DURATION) * 2 * Math.PI;

            const openingColor = '#facc15'; // Yellow
            const openColor = '#22c55e'; // Green
            const closingColor = '#ef4444'; // Red
            const overlayColor = 'rgba(93, 64, 55, 0.6)'; // Darkening overlay

            // Opening segment
            pieClockCtx.fillStyle = openingColor;
            pieClockCtx.beginPath();
            pieClockCtx.moveTo(centerX, centerY);
            pieClockCtx.arc(centerX, centerY, radius, startAngle, startAngle + openingAngle);
            pieClockCtx.closePath();
            pieClockCtx.fill();

            // Open segment
            pieClockCtx.fillStyle = openColor;
            pieClockCtx.beginPath();
            pieClockCtx.moveTo(centerX, centerY);
            pieClockCtx.arc(centerX, centerY, radius, startAngle + openingAngle, startAngle + openingAngle + openAngle);
            pieClockCtx.closePath();
            pieClockCtx.fill();

            // Closing segment
            pieClockCtx.fillStyle = closingColor;
            pieClockCtx.beginPath();
            pieClockCtx.moveTo(centerX, centerY);
            pieClockCtx.arc(centerX, centerY, radius, startAngle + openingAngle + openAngle, startAngle + 2 * Math.PI);
            pieClockCtx.closePath();
            pieClockCtx.fill();

            if (dayStarted) {
                 const progressAngle = ((DAY_DURATION - dayTimer) / DAY_DURATION) * 2 * Math.PI;
                 pieClockCtx.fillStyle = overlayColor;
                 pieClockCtx.beginPath();
                 pieClockCtx.moveTo(centerX, centerY);
                 pieClockCtx.arc(centerX, centerY, radius + 1, startAngle + progressAngle, startAngle + 2 * Math.PI);
                 pieClockCtx.closePath();
                 pieClockCtx.fill();
            } else {
                // If day is over, cover whole pie
                pieClockCtx.fillStyle = overlayColor;
                pieClockCtx.beginPath();
                pieClockCtx.arc(centerX, centerY, radius + 1, 0, 2 * Math.PI);
                pieClockCtx.fill();
            }

            // Border
            pieClockCtx.strokeStyle = '#5d4037';
            pieClockCtx.lineWidth = 2;
            pieClockCtx.beginPath();
            pieClockCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            pieClockCtx.stroke();
        }

        function handleClockClick() {
            if (!dayStarted) return;

            if (dayPhase === 'opening') {
                dayTimer = OPEN_DURATION + CLOSING_DURATION;
                dayPhase = 'open'; // Manually update phase
                spawnFloatingText('Opening Skipped!', canvas.width / 2, 120, '#facc15');
            } else if (dayPhase === 'open') {
                dayTimer = CLOSING_DURATION;
                dayPhase = 'closing'; // Manually update phase
                spawnFloatingText('Day Ended Early!', canvas.width / 2, 120, '#22c55e');
            } else if (dayPhase === 'closing') {
                dayTimer = 1; // Set to 1ms to trigger nextDay() on the next frame
                spawnFloatingText('Closing Skipped!', canvas.width / 2, 120, '#ef4444');
            }
        }

        function gameLoop(timestamp) {
            if (!running || !lastTimestamp) {
                lastTimestamp = timestamp;
                requestAnimationFrame(gameLoop);
                return;
            }
            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;

            if (dayStarted) {
                dayTimer -= deltaTime;

                if (!midDayBreakTriggered && dayTimer <= (DAY_DURATION / 2)) {
                    midDayBreakTriggered = true;
                    isMandatoryBreak = true;
                    spawnFloatingText("LUNCH BREAK!", canvas.width / 2, 120, '#3b82f6');

                    const employees = { cashier, stocker, loader, manager, salesperson };
                    for (const empKey in employees) {
                        if (unlocks.employees[empKey]) {
                            employees[empKey].onBreak = true;
                        }
                    }

                    if (activePanel === 'employees') {
                        openEmployeesPanel();
                    }

                    setTimeout(() => {
                        isMandatoryBreak = false;
                        for (const empKey in employees) {
                            if (unlocks.employees[empKey]) {
                                if (!employees[empKey].playerInitiatedBreak) {
                                    employees[empKey].onBreak = false;
                                }
                            }
                        }
                        if (activePanel === 'employees') {
                            openEmployeesPanel();
                        }
                        spawnFloatingText("Break's over!", canvas.width / 2, 120, '#22c55e');
                    }, 20000);
                }

                if (dayTimer > OPEN_DURATION + CLOSING_DURATION) {
                    dayPhase = 'opening';
                } else if (dayTimer > CLOSING_DURATION) {
                    dayPhase = 'open';
                } else if (dayTimer > 0) {
                    dayPhase = 'closing';
                } else {
                    dayPhase = 'pre-open';
                    nextDay();
                }
            }

            updatePlayer(deltaTime);

            // Zone 1 point system
            if (isPlayerInZone(officeZone1)) {
                zone1PointTimer += deltaTime;
                if (zone1PointTimer >= 5000) { // 5 seconds
                    shopPoints++;
                    zone1PointTimer -= 5000;
                    updateUI();
                    spawnFloatingText("+1 Point", player.x, player.y - 90, "#f59e0b");
                }
            } else {
                zone1PointTimer = 0;
            }

            updateStocker(deltaTime);
            updateCashier(deltaTime);
            updateLoader(deltaTime);
            updateManager(deltaTime);
            updateSalesperson(deltaTime);

            if (activeShelf) {
                const shelf = activeShelf;
                const dist = Math.hypot(player.x - (shelf.rect.x + shelf.rect.w/2), player.y - (shelf.rect.y + shelf.rect.h/2));
                if (dist > 200) {
                    togglePanel('shelf', false);
                }
            }
            if (activeStorageCell) {
                const cell = activeStorageCell;
                const dist = Math.hypot(player.x - (cell.rect.x + cell.rect.w/2), player.y - (cell.rect.y + cell.rect.h/2));
                if (dist > 200) {
                    togglePanel('storage', false);
                }
            }

            if (dayPhase === 'open') {
                timeSinceLastCustomer += deltaTime;
                if (timeSinceLastCustomer >= CUSTOMER_SPAWN_INTERVAL) {
                    timeSinceLastCustomer = 0;
                    spawnNewCustomer();
                }
            }

            customers.forEach(customer => customer.update(deltaTime));
            customers = customers.filter(c => c.x < canvas.width + 100 && c.x > -100);
            populateInStoreCustomers();

            // Real-time clipboard updates
            clipboardUpdateTimer += deltaTime;
            if (activePanel === 'customers' && clipboardUpdateTimer >= CLIPBOARD_UPDATE_INTERVAL) {
                const inStoreList = document.getElementById('in-store-customer-list');
                // Only update if the "In Store" tab is visible
                if (inStoreList && inStoreList.offsetParent !== null) {
                    populateInStoreCustomers();
                }
                clipboardUpdateTimer = 0;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();

            // Smooth camera movement
            const cameraSpeed = 0.05;
            cameraX += (targetCameraX - cameraX) * cameraSpeed;

            // cameraX = canvas.width / 2 - player.x;
            cameraY = 0;
            clampCamera();
            ctx.translate(cameraX, cameraY);

            drawStoreBackground();
            const dynamicEntities = [...customers, { y: cashierCounter.y + cashierCounter.h, type: 'cashier-counter' }, ...shelves, { draw: drawPlayer, y: player.y }, { draw: drawStocker, y: stocker.y }, { draw: drawCashier, y: cashier.y }, { draw: drawLoader, y: loader.y }, { draw: drawManager, y: manager.y }, { draw: drawSalesperson, y: salesperson.y }];
            dynamicEntities.sort((a, b) => (a.y || (a.rect ? a.rect.y + a.rect.h : 0)) - (b.y || (b.rect ? b.rect.y + b.rect.h : 0)));
            dynamicEntities.forEach(entity => {
                if (entity.draw) entity.draw();
            });
            drawOfficeZones();
            drawPackages();
            updateAndDrawFloatingTexts(deltaTime);

            ctx.restore();

            drawStaticUI();
            drawPieClock();

            requestAnimationFrame(gameLoop);
        }

        async function spawnNewCustomer() {
            if (customers.length >= 7) return;
            const customerData = await generateCustomerRequest();
            if (customerData && customerData.requestedItems) {
                const newCustomer = new Customer(
                    customerProfiles[customerData.customerType][customerData.name], // Pass the profile object
                    customerData.name,
                    customerData.request,
                    customerData.requestedItems,
                    customerData.customerType
                );
                customers.push(newCustomer);
                generateAndLoadCustomerSprite(newCustomer);
                populateInStoreCustomers();
            }
        }

        function updateUI() {
            document.getElementById('cash-display').textContent = Math.round(cash);
            document.getElementById('day-display').textContent = day;
            document.getElementById('shop-points-display').textContent = shopPoints;
        }


        function logCustomerToSalesReport(customer) {
            dailySalesReport.push({
                name: customer.name,
                typeKey: customer.customerType,
                requestedItems: customer.requestedItems,
                purchasedItems: [...customer.order],
                waitTime: Math.round(customer.waitTimer),
                patienceChange: customer.profile.patience - customer.initialPatience,
                discount: customer.discount
            });
        }

        function completeTransaction(customerId) {
            const customer = customers.find(c => c.id === customerId);
            if (!customer || customer.isServed) {
                console.warn("Attempted to complete transaction for non-existent/served customer:", customerId);
                return;
            }

            if (customer.order.length === 0) {
                logCustomerToSalesReport(customer);
                customer.leaving = true;
                customer.state = 'leaving';
                return;
            }

            let totalCost = 0;
            customer.order.forEach(item => {
                totalCost += items[item].cost;
            });
            let salePrice = Math.ceil(totalCost * 1.5);

            // Apply discount if applicable
            if (customer.discount > 0) {
                salePrice = Math.ceil(salePrice * (1 - customer.discount));
            }

            customer.isServed = true;

            if (salePrice <= customer.budget) {
                cash += salePrice;
                shopPoints += customer.discount > 0 ? 1 : 3; // Less points for discounted sales
                customer.leaving = true;
                customer.state = 'leaving';
                const saleText = customer.discount > 0 ? `+$${salePrice} (Discounted)` : `+$${salePrice}`;
                spawnFloatingText(saleText, customer.x, customer.y - 80, '#22c55e');

                // Track popularity of sold items
                customer.order.forEach(item => {
                    itemPopularity[item] = (itemPopularity[item] || 0) + 1;
                });

            } else {
                customer.order.forEach(item => {
                    const shelfToReturn = shelves.find(s => s.items.some(i => i && i.assignedItem === item) || s.items.some(i => i.assignedItem === null));
                    if(shelfToReturn) {
                        let slot = shelfToReturn.items.find(i => i && i.assignedItem === item);
                        if(slot) slot.quantity++;
                        else {
                            const emptySlot = shelfToReturn.items.find(i => i.assignedItem === null);
                            if(emptySlot) {
                                emptySlot.assignedItem = item;
                                emptySlot.quantity = 1;
                            }
                        }
                    }
                });

                customer.leaving = true;
                customer.state = 'leaving';
                spawnFloatingText('Too Expensive!', customer.x, customer.y - 80, '#ef4444');
            }
            logCustomerToSalesReport(customer);
            updateUI();
            populateInStoreCustomers();
            saveGame();
        }

        function endGame() {
            running = false;
            showMessage(`Game Over! You ran out of money. You survived for ${day} days and ended with $${Math.round(cash)}.`, null);
        }

        function nextDay() {
            if (!dayStarted) return;
            dayStarted = false;
            dayPhase = 'pre-open';
            midDayBreakTriggered = false;
            manager.hasPlacedMorningOrder = false; // Reset for the next day
            const dailyExpenses = 25;
            cash -= dailyExpenses;
            customers.forEach(c => c.state = 'leaving');
            timeSinceLastCustomer = 0;
            if (cash < 0) {
                updateUI();
                endGame();
                return;
            }
            updateUI();
            const reportPanel = document.getElementById('end-of-day-panel');
            const reportList = document.getElementById('sales-report-list');
            reportList.innerHTML = '';
            let grossSales = 0;
            const salesTally = {};
            const missedTally = {};
            dailySalesReport.forEach(report => {
                const reportDiv = document.createElement('div');
                reportDiv.className = 'text-sm p-2 border-b border-amber-800/20';
                const patienceColor = report.patienceChange < 0 ? 'text-red-600' : 'text-green-600';
                const patienceSign = report.patienceChange >= 0 ? '+' : '';
                let purchaseSummary = '<span class="text-red-600 font-bold">Left without buying</span>';
                if (report.purchasedItems.length > 0) {
                    const itemCosts = report.purchasedItems.map(item => items[item].cost);
                    const totalCost = itemCosts.reduce((a, b) => a + b, 0);
                    let salePrice = Math.ceil(totalCost * 1.5);
                    if (report.discount > 0) {
                        salePrice = Math.ceil(salePrice * (1 - report.discount));
                    }
                    grossSales += salePrice;
                    purchaseSummary = `${report.purchasedItems.join(', ')} ($${salePrice})`;
                    if (report.discount > 0) {
                        purchaseSummary += ` <span class="text-red-600 font-bold">(${report.discount * 100}% off)</span>`;
                    }
                    report.purchasedItems.forEach(item => salesTally[item] = (salesTally[item] || 0) + 1);
                }
                const missedItems = report.requestedItems.filter(item => !report.purchasedItems.includes(item));
                missedItems.forEach(item => missedTally[item] = (missedTally[item] || 0) + 1);
                const starButtonId = `star-btn-${report.name.replace(/\s+/g, '-')}`;
                reportDiv.innerHTML = `
            <div class="font-bold flex justify-between items-center">${report.name} <button id="${starButtonId}" class="text-2xl">${customerProfiles[report.typeKey][report.name].isStarred ? '⭐' : '☆'}</button></div>
            <div>Purchased: <span class="font-handwritten">${purchaseSummary}</span></div>
            <div>Intended: <span class="font-handwritten">${report.requestedItems.join(', ')}</span></div>
            <div>Wait Time: <span class="font-handwritten">${report.waitTime}s</span> | Patience: <span class="font-handwritten ${patienceColor}">${patienceSign}${report.patienceChange}</span></div>
        `;
                reportList.appendChild(reportDiv);
                document.getElementById(starButtonId).addEventListener('click', (e) => {
                    const profile = customerProfiles[report.typeKey][report.name];
                    profile.isStarred = !profile.isStarred;
                    e.target.textContent = profile.isStarred ? '⭐' : '☆';
                });
            });
            const topSeller = Object.keys(salesTally).length ? Object.entries(salesTally).sort((a, b) => b[1] - a[1])[0][0] : 'None';
            const topMiss = Object.keys(missedTally).length ? Object.entries(missedTally).sort((a, b) => b[1] - a[1])[0][0] : 'None';
            const extraSummaryDiv = document.getElementById('report-summary-extra');
            extraSummaryDiv.innerHTML = `
        <p class="border-t border-amber-800/30 pt-2 mt-2">Top Seller: <span class="font-bold">${topSeller}</span></p>
        <p>Most Missed: <span class="font-bold">${topMiss}</span></p>
    `;
            document.getElementById('report-day').textContent = day;
            document.getElementById('report-sales').textContent = `$${grossSales}`;
            document.getElementById('report-expenses').textContent = `-$${dailyExpenses}`;
            document.getElementById('report-profit').textContent = `$${grossSales - dailyExpenses}`;
            reportPanel.classList.remove('hidden');
            document.getElementById('next-day-report-btn').onclick = () => {
                day++;
                for (const type in customerProfiles) {
                    for (const name in customerProfiles[type]) {
                        customerProfiles[type][name].visitedToday = false;
                    }
                }
                Object.keys(inventory).forEach(item => {
                    if (inventory[item] < 5) inventory[item] += 1;
                });
                saveGame();
                reportPanel.classList.add('hidden');
                dailySalesReport = [];
                document.getElementById('start-day-btn').click();
            };
        }

        // --- LAYOUT INITIALIZATION ---
        // The following values determine the layout of the store.
        // This layout has been finalized and should not be changed.
        function initializeLayout() {
            officeWidth = canvas.width / 4;
            const storeShiftX = officeWidth;

            const cellWidth = canvas.width / 5;
            const cellHeight = ((desk.y - 250) / 2) * 0.8;
            const topPadding = 90;
            const cellPadding = 20;

            storageCells = [
                // Bottom Row
                { label: "Drawing", rect: { x: storeShiftX + cellPadding * 2, y: topPadding + cellHeight + 60, w: cellWidth, h: cellHeight }, allowedItems: ['Pencil', 'Charcoal', 'Markers', 'Sketchbook'], items: {}, capacity: 50 },
                { label: "Painting", rect: { x: storeShiftX + canvas.width / 2 - cellWidth / 2, y: topPadding + cellHeight + 60, w: cellWidth, h: cellHeight }, allowedItems: ['Water Color', 'Oils', 'Acrylics', 'Canvas'], items: {}, capacity: 50 },
                { label: "Models", rect: { x: storeShiftX + canvas.width - cellWidth - cellPadding * 2, y: topPadding + cellHeight + 60, w: cellWidth, h: cellHeight }, allowedItems: ['Razors', 'Glue', 'Mini Paints', 'Model Kits'], items: {}, capacity: 50 },
                // Top Row
                { label: "Woodworking", rect: { x: storeShiftX + cellPadding * 2, y: topPadding + 20, w: cellWidth, h: cellHeight }, allowedItems: ['Sanding Paper', 'Stainer', 'Wood Scraps', 'Lumber'], items: {}, capacity: 50 },
                { label: "Sculpture", rect: { x: storeShiftX + canvas.width / 2 - cellWidth / 2, y: topPadding + 20, w: cellWidth, h: cellHeight }, allowedItems: ['Clay', 'Pottery Paints', 'Stone', 'Marble'], items: {}, capacity: 50 },
                { label: "Architectural", rect: { x: storeShiftX + canvas.width - cellWidth - cellPadding * 2, y: topPadding + 20, w: cellWidth, h: cellHeight }, allowedItems: ['Pencil Lead', 'Vellum', 'Fancy Markers', 'Tiny Trees'], items: {}, capacity: 50 }
            ];

            cashierCounter.x = storeShiftX + 141;
            cashierCounter.y = (desk.y - cashierCounter.h) + 141;

            managersOffice.w = officeWidth;
            managersOffice.h = canvas.height / 2;
            managersOffice.x = 0;
            managersOffice.y = (canvas.height - managersOffice.h) / 2;

            // --- Office Zone Calculations ---
            const zoneSize = 80;
            const zonePadding = 20;

            // Zone 3 (Break Room) - Inside the office
            officeZone3.w = managersOffice.w * 0.7;
            officeZone3.h = managersOffice.h * 0.5;
            officeZone3.x = managersOffice.x + (managersOffice.w - officeZone3.w) / 2;
            officeZone3.y = managersOffice.y + (managersOffice.h - officeZone3.h) / 2 + 30; // Shift down a bit

            // Zone 1 & 2 (Desk & Waiting) - Below the office
            officeZone1.w = zoneSize;
            officeZone1.h = zoneSize;
            officeZone1.x = managersOffice.x + zonePadding;
            officeZone1.y = managersOffice.y + managersOffice.h + zonePadding;

            officeZone2.w = zoneSize;
            officeZone2.h = zoneSize;
            officeZone2.x = officeZone1.x + officeZone1.w + zonePadding;
            officeZone2.y = officeZone1.y;

            const shelfWidth = 60, shelfHeight = 120;
            const shelfY = desk.y - shelfHeight + 40;

            const numShelves = 6;
            const shelfPadding = 50;
            const totalShelvesWidth = (numShelves * shelfWidth) + ((numShelves - 1) * shelfPadding);
            const startX = storeShiftX + (canvas.width - totalShelvesWidth) / 2;
            if (shelves.length === 0) {
                for (let i = 0; i < numShelves; i++) {
                    const shelf = {
                        rect: { x: startX + i * (shelfWidth + shelfPadding), y: shelfY, w: shelfWidth, h: shelfHeight },
                        items: [
                            { assignedItem: null, quantity: 0 },
                            { assignedItem: null, quantity: 0 },
                            { assignedItem: null, quantity: 0 },
                            { assignedItem: null, quantity: 0 }
                        ],
                        y: shelfY + shelfHeight,
                        draw: drawShelf
                    };
                    shelves.push(shelf);
                }
            } else {
                 for (let i = 0; i < shelves.length; i++) {
                     shelves[i].rect.x = startX + i * (shelfWidth + shelfPadding);
                     shelves[i].rect.y = shelfY;
                     shelves[i].y = shelfY + shelfHeight;
                 }
            }
            const startY = cashierCounter.y + cashierCounter.h / 2;

            // --- Employee Idle Positions ---
            cashier.idleX = cashierCounter.x - 30;
            cashier.idleY = startY;
            if (cashier.state === 'idle' && !cashier.task) {
                cashier.x = cashier.idleX;
                cashier.y = cashier.idleY;
            }

            stocker.idleX = cashier.idleX - 40;
            stocker.idleY = startY;
            if (stocker.state === 'idle' && !stocker.task) {
                stocker.x = stocker.idleX;
                stocker.y = stocker.idleY;
            }

            manager.idleX = officeZone2.x + officeZone2.w / 2 - 20;
            manager.idleY = officeZone2.y + officeZone2.h / 2;
            if (manager.state === 'idle' && !manager.task) {
                manager.x = manager.idleX;
                manager.y = manager.idleY;
            }

            loader.idleX = officeZone2.x + officeZone2.w / 2 + 20;
            loader.idleY = officeZone2.y + officeZone2.h / 2;
            if (loader.state === 'idle' && !loader.task) {
                loader.x = loader.idleX;
                loader.y = loader.idleY;
            }

            salesperson.idleX = storeShiftX + canvas.width - 100;
            salesperson.idleY = 400;
            if (salesperson.state === 'idle' && !salesperson.task) {
                salesperson.x = salesperson.idleX;
                salesperson.y = salesperson.idleY;
            }

            if (day === 1 && !dayStarted) {
                player.x = stocker.idleX - 40;
                player.y = startY;
            }
        }

        // --- REFACTOR: Standalone Shelf Drawing Function ---
        function drawShelf() {
            const shelfIndex = shelves.indexOf(this);
             if (!unlocks.shelves[shelfIndex]) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h);
                drawLockIcon(this.rect.x + this.rect.w / 2 - 25, this.rect.y + this.rect.h / 2 - 25, 50, 50);
                return;
            }
            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h);
            ctx.strokeStyle = '#4e342e';
            ctx.lineWidth = 4;
            ctx.strokeRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h);
            ctx.fillStyle = '#6d4c41';
            ctx.fillRect(this.rect.x, this.rect.y, this.rect.w, 10);
            ctx.strokeStyle = '#6d4c41';
            ctx.lineWidth = 2;
            const slotHeight = (this.rect.h - 10) / 4;
            ctx.beginPath();
            ctx.moveTo(this.rect.x, this.rect.y + 10 + slotHeight);
            ctx.lineTo(this.rect.x + this.rect.w, this.rect.y + 10 + slotHeight);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(this.rect.x, this.rect.y + 10 + slotHeight * 2);
            ctx.lineTo(this.rect.x + this.rect.w, this.rect.y + 10 + slotHeight * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(this.rect.x, this.rect.y + 10 + slotHeight * 3);
            ctx.lineTo(this.rect.x + this.rect.w, this.rect.y + 10 + slotHeight * 3);
            ctx.stroke();
            const itemWidth = this.rect.w - 20;
            const itemHeight = (this.rect.h - 40) / 4;
            for (let i = 0; i < this.items.length; i++) {
                if (this.items[i] && this.items[i].assignedItem) {
                    const item = this.items[i];
                    const stackX = this.rect.x + 10;
                    const stackY = this.rect.y + 15 + i * (itemHeight + 5);
                    ctx.fillStyle = '#f5f5f5';
                    ctx.fillRect(stackX, stackY, itemWidth * (item.quantity / MAX_SHELF_STACK), itemHeight);
                    ctx.strokeStyle = '#5d4037';
                    ctx.strokeRect(stackX, stackY, itemWidth, itemHeight);
                    ctx.fillStyle = '#5d4037';
                    ctx.font = '12px "Patrick Hand", cursive';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(item.assignedItem.substring(0, 8), stackX + itemWidth / 2, stackY + itemHeight / 2);
                }
            }
        }


        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            desk.y = canvas.height - 220;

            initializeLayout();

            worldWidth = canvas.width + officeWidth;
            desk.width = worldWidth;
            loadingDock.y = canvas.height - loadingDock.height;
            loadingDock.x = officeWidth;
            loadingDock.width = canvas.width;
            cameraY = 0;

            if (cameraState === 'store') {
                 targetCameraX = -officeWidth;
                 cameraX = -officeWidth;
            } else {
                 targetCameraX = 0;
                 cameraX = 0;
            }
        }

        function clampCamera() {
            const worldWidth = canvas.width + officeWidth;
            const worldHeight = canvas.height;

            cameraX = Math.max(canvas.width - worldWidth, Math.min(0, cameraX));
            cameraY = Math.max(canvas.height - worldHeight, Math.min(0, cameraY));
        }

        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;

            const panelWidth = 70;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = 20;
            const panelHeight = 70;

            // Check for static UI clicks FIRST, before transforming coordinates
            if (x >= panelX && x <= panelX + panelWidth && y >= panelY && y <= panelY + panelHeight) {
                 if (x >= phoneIcon.x && x <= phoneIcon.x + phoneIcon.width && y >= phoneIcon.y && y <= phoneIcon.y + phoneIcon.height) { openPhonePanel(); }
                return;
            }

            // Convert to world coordinates for game object clicks
            const worldX = (x - cameraX);
            const worldY = (y - cameraY);

            // Check for clicks on packages in the loading dock
            if (worldY >= loadingDock.y) {
                 if (Math.hypot(player.x - worldX, player.y - worldY) < 150) {
                     for(let i = 0; i < loadingDockPackages.length; i++) {
                         const pkg = loadingDockPackages[i];
                         const pkgX = 10 + i * (PACKAGE_WIDTH + 10);
                         const pkgY = loadingDock.y + (loadingDock.height - PACKAGE_HEIGHT) / 2;
                         if(worldX > pkgX && worldX < pkgX + PACKAGE_WIDTH && worldY > pkgY && worldY < pkgY + PACKAGE_HEIGHT) {
                             takeItemFromPackage(i);
                             return;
                         }
                     }
                 }
            }

            const clickedCell = storageCells.find(c => worldX >= c.rect.x && worldX <= c.rect.x + c.rect.w && worldY >= c.rect.y && worldY <= c.rect.y + c.rect.h);
            if (clickedCell) {
                if (Math.hypot(player.x - (clickedCell.rect.x + clickedCell.rect.w/2), player.y - (clickedCell.rect.y + clickedCell.rect.h)) < 150) {
                    openStorageCell(clickedCell); return;
                }
            }
            const clickedShelf = shelves.find(s => worldX >= s.rect.x && worldX <= s.rect.x + s.rect.w && worldY >= s.rect.y && worldY <= s.rect.y + s.rect.h);
            if (clickedShelf) {
                if (Math.hypot(player.x - (clickedShelf.rect.x + clickedShelf.rect.w/2), player.y - (clickedShelf.rect.y + clickedShelf.rect.h/2)) < 150) {
                    openShelfPanel(clickedShelf);
                    return;
                }
            }

            // If no specific object was clicked, set the player's target destination.
            player.targetX = worldX;
            player.targetY = worldY;

        }

        function isPlayerInZone(zone) {
            return player.x > zone.x && player.x < zone.x + zone.w &&
                   player.y > zone.y && player.y < zone.y + zone.h;
        }

        function handleInteraction() {
            // Priority 1: Check out a customer if they are waiting and player is at the counter.
            const customerToCheckout = customers
                .filter(c => c.state === 'waitingAtCounter' && !c.isServed)
                .sort((a, b) => a.x - b.x)[0]; // Get the first person in line

            const playerAtCounter = Math.hypot(player.x - (cashierCounter.x - 30), player.y - (cashierCounter.y + cashierCounter.h / 2)) < 100;

            if (customerToCheckout && playerAtCounter) {
                completeTransaction(customerToCheckout.id);
                return; // Interaction handled, do nothing else.
            }

            // Find the closest customer the player can interact with
            const nearbyCustomer = customers.find(c =>
                !c.leaving &&
                c.state !== 'waitingAtCounter' &&
                c.state !== 'queuing' &&
                Math.hypot(player.x - c.x, player.y - c.y) < 150
            );

            if (!nearbyCustomer) return; // No one nearby to interact with

            // --- New Interaction Logic for Waiting Customers (PRIORITY CHECK) ---
            if (nearbyCustomer.waitTimer > 60) { // Check for 60 seconds
                // Scenario A: Customer has items and has been waiting.
                if (nearbyCustomer.order.length > 0) {
                    nearbyCustomer.discount = 0.25; // Apply 25% discount
                    nearbyCustomer.state = 'queuing';
                    nearbyCustomer.request = "Alright, I'll take what you have for a discount.";
                    spawnFloatingText("Deal Made!", nearbyCustomer.x, nearbyCustomer.y - 90, '#3b82f6');
                    return;
                }
                // Scenario B: Customer has no items and has been waiting.
                else {
                    if (Math.random() < 0.5) {
                        // 50% chance: Buy a random in-stock item.
                        const allStockedItems = [];
                        shelves.forEach(shelf => {
                            shelf.items.forEach(slot => {
                                if (slot.assignedItem && slot.quantity > 0) {
                                    allStockedItems.push(slot.assignedItem);
                                }
                            });
                        });

                        if (allStockedItems.length > 0) {
                            const randomItem = allStockedItems[Math.floor(Math.random() * allStockedItems.length)];
                            nearbyCustomer.order.push(randomItem);
                            nearbyCustomer.profile.patience -= 10; // Small patience hit
                            nearbyCustomer.patience = nearbyCustomer.profile.patience; // Sync instance
                            nearbyCustomer.state = 'queuing';
                            nearbyCustomer.request = `Alright, I'll take a ${randomItem} then.`;
                            spawnFloatingText("Convinced!", nearbyCustomer.x, nearbyCustomer.y - 90, '#f59e0b');
                        } else {
                            // No items in stock, so they just leave.
                            nearbyCustomer.profile.patience -= 30; // Large patience hit
                            nearbyCustomer.patience = nearbyCustomer.profile.patience; // Sync instance
                            logCustomerToSalesReport(nearbyCustomer);
                            nearbyCustomer.state = 'leaving';
                            nearbyCustomer.request = "There's nothing here! I'm leaving.";
                            spawnFloatingText("Leaving Angry!", nearbyCustomer.x, nearbyCustomer.y - 90, '#ef4444');
                        }
                    } else {
                        // 50% chance: Leave the store.
                        nearbyCustomer.profile.patience -= 30; // Large patience hit
                        nearbyCustomer.patience = nearbyCustomer.profile.patience; // Sync instance
                        logCustomerToSalesReport(nearbyCustomer);
                        nearbyCustomer.state = 'leaving';
                        nearbyCustomer.request = "I've waited long enough. Goodbye.";
                        spawnFloatingText("Leaving Angry!", nearbyCustomer.x, nearbyCustomer.y - 90, '#ef4444');
                    }
                    return;
                }
            }

            // --- Original Interaction Logic ---
            if (nearbyCustomer.behaviorType === 'needsInteraction' && !nearbyCustomer.isInteractedWith) {
                nearbyCustomer.isInteractedWith = true;
                spawnFloatingText("Right this way!", player.x, player.y - 90, '#3b82f6');
                nearbyCustomer.showSpeechBubble = true;
                nearbyCustomer.speechBubbleTimer = 3000;
                return;
            }

            if (nearbyCustomer.behaviorType === 'needsAssistance' && !nearbyCustomer.needsAssistanceFulfilled) {
                const neededItems = nearbyCustomer.requestedItems.filter(item => !nearbyCustomer.order.includes(item));
                const playerBasketCounts = player.basket.reduce((acc, item) => { acc[item] = (acc[item] || 0) + 1; return acc; }, {});
                const neededItemsCounts = neededItems.reduce((acc, item) => { acc[item] = (acc[item] || 0) + 1; return acc; }, {});
                const canFulfill = Object.keys(neededItemsCounts).every(item => (playerBasketCounts[item] || 0) >= neededItemsCounts[item]);

                if (canFulfill && neededItems.length > 0) {
                    neededItems.forEach(item => {
                        const index = player.basket.indexOf(item);
                        player.basket.splice(index, 1);
                        nearbyCustomer.order.push(item);
                    });

                    nearbyCustomer.waitTimer = 0; // Reset wait timer
                    nearbyCustomer.state = 'queuing';
                    nearbyCustomer.needsAssistanceFulfilled = true;
                    nearbyCustomer.request = `Oh, you have everything! Thanks! I'll go pay now.`;
                    nearbyCustomer.showSpeechBubble = true;
                    nearbyCustomer.speechBubbleTimer = 3000;
                    spawnFloatingText('Order Fulfilled!', player.x, player.y - 90, '#3b82f6');
                    return;
                }
            }

            // Default interaction: show speech bubble and maybe upsell
            if (nearbyCustomer.state === 'wandering' || nearbyCustomer.state === 'waitingForInteraction' || nearbyCustomer.state === 'waitingForAssistance') {
                 const missingItem = nearbyCustomer.requestedItems[nearbyCustomer.currentItemIndex];
                 if (missingItem) {
                     nearbyCustomer.request = `I was really hoping to find some ${missingItem} today.`;
                 } else if (nearbyCustomer.behaviorType === 'needsInteraction') {
                     nearbyCustomer.request = "Hello? Could someone help me find something?";
                 } else if (nearbyCustomer.behaviorType === 'needsAssistance') {
                     nearbyCustomer.request = "Could someone get these items for me, please?";
                 }
            }
            nearbyCustomer.showSpeechBubble = true;
            nearbyCustomer.speechBubbleTimer = 3000;

            if (Math.random() < 0.10 && nearbyCustomer.requestedItems.length < 4 && nearbyCustomer.behaviorType !== 'needsAssistance') {
                const allItems = Object.keys(items);
                const potentialItems = allItems.filter(i => !nearbyCustomer.requestedItems.includes(i));
                if (potentialItems.length > 0) {
                    const newItem = potentialItems[Math.floor(Math.random() * potentialItems.length)];
                    nearbyCustomer.requestedItems.push(newItem);
                    nearbyCustomer.request += ` and maybe a ${newItem}?`;
                    spawnFloatingText('Upsell!', player.x, player.y - 90, '#8b5cf6');
                }
            }
        }

        function populateAllCustomers() {
            const customerList = document.getElementById('all-customer-list');
            customerList.innerHTML = '';

            const unlockedTypeKeys = ['artist'];
            unlocks.storage.forEach((isUnlocked, index) => {
                if (isUnlocked) {
                    const typeKey = Object.keys(customerTypes).find(key => customerTypes[key].storageIndex === index);
                    if (typeKey && !unlockedTypeKeys.includes(typeKey)) {
                        unlockedTypeKeys.push(typeKey);
                    }
                }
            });

            unlockedTypeKeys.forEach(typeKey => {
                const typeInfo = customerTypes[typeKey];
                const profilesForType = customerProfiles[typeKey];

                const typeContainer = document.createElement('div');
                const typeHeader = document.createElement('h3');
                typeHeader.className = 'font-handwritten text-xl mt-4 px-1 border-b-2 border-amber-800/30 flex justify-between items-center cursor-pointer';
                typeHeader.innerHTML = `<span>${typeInfo.name}</span><span class="text-sm mr-2">[+]</span>`;

                const customerSubList = document.createElement('div');
                customerSubList.className = 'pl-2 hidden'; // Initially hidden

                typeContainer.appendChild(typeHeader);
                typeContainer.appendChild(customerSubList);
                customerList.appendChild(typeContainer);

                typeHeader.addEventListener('click', () => {
                    const isHidden = customerSubList.classList.toggle('hidden');
                    typeHeader.querySelector('span:last-child').textContent = isHidden ? '[+]' : '[-]';
                });

                if (!profilesForType) return;

                for (const name in profilesForType) {
                    const profile = profilesForType[name];
                    const customerDiv = document.createElement('div');
                    customerDiv.className = 'p-3 border-2 border-amber-800/50 rounded-lg bg-white/50 grid grid-cols-2 gap-x-4';

                    let visitedStatus = profile.visitedToday
                        ? '<span class="font-bold text-green-600">Visited</span>'
                        : '<span class="font-bold text-red-600">Not Visited</span>';

                    customerDiv.innerHTML = `
                        <div class="font-bold text-lg col-span-2">${name}</div>
                        <div>Patience: <span class="font-handwritten">${Math.round(profile.patience)}</span></div>
                        <div>Status: ${visitedStatus}</div>
                        <div class="col-span-2 mt-1">Tools: <span class="font-handwritten text-sm">${profile.toolsOwned.length > 0 ? profile.toolsOwned.join(', ') : 'None'}</span></div>
                    `;
                    customerSubList.appendChild(customerDiv);
                }
            });
        }

        function populateInStoreCustomers() {
            const customerList = document.getElementById('in-store-customer-list');
            customerList.innerHTML = '';

            const activeCustomers = customers.filter(c => !c.leaving);

            if (activeCustomers.length === 0) {
                customerList.innerHTML = `<p class="text-center p-4">No customers in the shop.</p>`;
                return;
            }

            activeCustomers.forEach(customer => {
                const customerDiv = document.createElement('div');
                customerDiv.className = 'p-3 border-2 border-amber-800/50 rounded-lg bg-white/50 cursor-pointer hover:bg-amber-200/50 transition-colors';
                customerDiv.dataset.customerId = customer.id;

                let status = '';
                if (customer.waitTimer > 60) {
                    status = `<span class="font-bold text-yellow-600 animate-pulse">Needs Attention!</span>`;
                } else if (customer.state === 'waitingAtCounter') {
                    status = `<span class="font-bold text-green-600">Ready to Checkout</span>`;
                } else {
                    status = `<span class="text-gray-500">${customer.state}</span>`;
                }

                customerDiv.innerHTML = `
                    <div class="flex justify-between items-center">
                        <div class="font-bold text-lg">${customer.name}</div>
                        <div>${status}</div>
                    </div>
                    <div class="text-sm">Wait Time: ${Math.round(customer.waitTimer)}s</div>
                    <div class="text-xs mt-1">Looking for: <span class="font-handwritten">${customer.requestedItems.join(', ')}</span></div>
                `;

                customerDiv.addEventListener('click', () => {
                    const targetCustomer = customers.find(c => c.id === customer.id);
                    if (targetCustomer) {
                        player.targetX = targetCustomer.x;
                        player.targetY = targetCustomer.y + 20; // Target slightly below for better pathing
                    }
                });
                customerList.appendChild(customerDiv);
            });
        }

        function openCustomersPanel() {
            const inStoreBtn = document.getElementById('in-store-customers-btn');
            const allBtn = document.getElementById('all-customers-btn');
            const inStoreList = document.getElementById('in-store-customer-list');
            const allList = document.getElementById('all-customer-list');

            function showInStore() {
                inStoreList.classList.remove('hidden');
                allList.classList.add('hidden');
                inStoreBtn.classList.remove('bg-opacity-50');
                allBtn.classList.add('bg-opacity-50');
                populateInStoreCustomers();
            }

            function showAll() {
                inStoreList.classList.add('hidden');
                allList.classList.remove('hidden');
                allList.classList.add('flex'); // Make it a flex container
                inStoreBtn.classList.add('bg-opacity-50');
                allBtn.classList.remove('bg-opacity-50');
                populateAllCustomers();
            }

            inStoreBtn.onclick = showInStore;
            allBtn.onclick = showAll;

            showInStore();
            showAppScreen('customers-panel');
        }

        function openEmployeesPanel() {
            const employeeList = document.getElementById('employee-list');
            employeeList.innerHTML = '';

            const employees = { cashier, stocker, loader, manager, salesperson };

            let anyUnlocked = false;
            for (const empKey in unlocks.employees) {
                if (unlocks.employees[empKey]) {
                    anyUnlocked = true;
                    const employee = employees[empKey];
                    const empDiv = document.createElement('div');
                    empDiv.className = 'flex items-center justify-between p-3 border-2 border-amber-800/50 rounded-lg bg-white/50';
                    empDiv.innerHTML = `
                        <span class="text-lg">${empKey.charAt(0).toUpperCase() + empKey.slice(1)}</span>
                        <div class="flex items-center">
                            <span class="mr-2 text-sm">${employee.onBreak ? 'On Break' : 'Active'}</span>
                            <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                                <input type="checkbox" name="${empKey}-toggle" id="${empKey}-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" ${employee.onBreak ? 'checked' : ''}/>
                                <label for="${empKey}-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                            </div>
                        </div>
                    `;
                    employeeList.appendChild(empDiv);
                    const toggle = empDiv.querySelector(`#${empKey}-toggle`);
                    toggle.addEventListener('change', (e) => {
                        employee.onBreak = e.target.checked;
                        employee.playerInitiatedBreak = e.target.checked;
                        openEmployeesPanel();
                        saveGame();
                    });

                    if (isMandatoryBreak) {
                        toggle.disabled = true;
                    }
                }
            }

            if (!anyUnlocked) {
                employeeList.innerHTML = `<p class="text-center p-4">No employees hired yet.</p>`;
            }
            showAppScreen('employees-panel');
        }

        function openBasketPanel() {
            const basketGrid = document.getElementById('basket-grid');
            basketGrid.innerHTML = '';

            if (player.basket.length === 0) {
                basketGrid.innerHTML = `<p class="text-center p-4">Your basket is empty.</p>`;
            } else {
                const itemCounts = player.basket.reduce((acc, item) => {
                    acc[item] = (acc[item] || 0) + 1;
                    return acc;
                }, {});

                for (const item in itemCounts) {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'p-2 border-b border-amber-800/20 flex justify-between items-center';
                    itemDiv.innerHTML = `
                        <span class="text-lg">${item}</span>
                        <span class="font-handwritten text-xl">x${itemCounts[item]}</span>
                    `;
                    basketGrid.appendChild(itemDiv);
                }
            }

            showAppScreen('basket-panel');
        }

        function openShelfAssignmentPanel() {
            const shelfAssignmentGrid = document.getElementById('shelf-assignment-grid');
            shelfAssignmentGrid.innerHTML = ''; // Clear existing buttons

            shelves.forEach((shelf, index) => {
                if (unlocks.shelves[index]) {
                    const shelfButton = document.createElement('button');
                    shelfButton.className = 'btn-style p-4';
                    shelfButton.textContent = `Shelf ${index + 1}`;
                    shelfButton.onclick = () => {
                        showShelfSlotsForAssignment(shelf);
                    };
                    shelfAssignmentGrid.appendChild(shelfButton);
                }
            });

            showAppScreen('shelf-assignment-panel');
        }

        function populateInStoreCustomers() {
            const customerList = document.getElementById('in-store-customer-list');
            if (!customerList) return; // Exit if the panel isn't open/doesn't exist
            customerList.innerHTML = '';

            const activeCustomers = customers.filter(c => !c.leaving);

            if (activeCustomers.length === 0) {
                customerList.innerHTML = `<p class="text-center p-4">No customers in the shop.</p>`;
                return;
            }

            activeCustomers.forEach(customer => {
                const customerDiv = document.createElement('div');
                customerDiv.className = 'p-3 border-2 border-amber-800/50 rounded-lg bg-white/50 cursor-pointer hover:bg-amber-200/50 transition-colors';
                customerDiv.dataset.customerId = customer.id;

                let status = '';
                if (customer.waitTimer > 60) {
                    status = `<span class="font-bold text-yellow-600 animate-pulse">Needs Attention!</span>`;
                } else if (customer.state === 'waitingAtCounter') {
                    status = `<span class="font-bold text-green-600">Ready to Checkout</span>`;
                } else {
                    status = `<span class="text-gray-500">${customer.state}</span>`;
                }

                customerDiv.innerHTML = `
                    <div class="flex justify-between items-center">
                        <div class="font-bold text-lg">${customer.name}</div>
                        <div>${status}</div>
                    </div>
                    <div class="text-sm">Wait Time: ${Math.round(customer.waitTimer)}s</div>
                    <div class="text-xs mt-1">Looking for: <span class="font-handwritten">${customer.requestedItems.join(', ')}</span></div>
                `;

                customerDiv.addEventListener('click', () => {
                    const targetCustomer = customers.find(c => c.id === customer.id);
                    if (targetCustomer) {
                        // When a customer is clicked, pan the camera to them
                        targetCameraX = -targetCustomer.x + canvas.width / 2;
                        closePhone();
                    }
                });
                customerList.appendChild(customerDiv);
            });
        }

        function showShelfSlotsForAssignment(shelf) {
            const shelfAssignmentGrid = document.getElementById('shelf-assignment-grid');
            const shelfAssignmentTitle = document.getElementById('shelf-assignment-title');
            shelfAssignmentGrid.innerHTML = ''; // Clear shelf buttons
            shelfAssignmentTitle.textContent = `Assign to Shelf ${shelves.indexOf(shelf) + 1}`;

            // Add a back button
            const backButton = document.createElement('button');
            backButton.className = 'btn-style bg-amber-700/80 hover:bg-amber-600 col-span-2';
            backButton.textContent = '← Back to Shelves';
            backButton.onclick = openShelfAssignmentPanel;
            shelfAssignmentGrid.appendChild(backButton);

            for (let i = 0; i < 4; i++) {
                const slot = shelf.items[i];
                const slotButton = document.createElement('button');
                slotButton.className = 'btn-style p-4';
                let buttonText = `Slot ${i + 1}`;
                if (slot.assignedItem) {
                    buttonText += ` (${slot.assignedItem.substring(0,8)})`;
                } else {
                    buttonText += ` (Empty)`;
                }
                slotButton.textContent = buttonText;
                slotButton.onclick = () => {
                    openProductAssignmentForShelf(shelf, i);
                };
                shelfAssignmentGrid.appendChild(slotButton);
            }
             togglePanel('shelf-assignment', true);
        }



        function takeItemFromPackage(packageIndex) {
            if (player.basket.length >= MAX_BASKET_SIZE) {
                showMessage("Your basket is full!");
                return;
            }
            const pkg = loadingDockPackages[packageIndex];
            if (pkg && pkg.quantity > 0) {
                player.basket.push(pkg.itemName);
                pkg.quantity--;
                if (pkg.quantity <= 0) {
                    loadingDockPackages.splice(packageIndex, 1);
                }
            }
        }


        let currentRestockOrder = {};
        let currentFavoritesOrder = {};

        function openPhonePanel() {
            const phonePanel = document.getElementById('phone-panel');
            phonePanel.classList.remove('hidden');
            isPhoneOpen = true;
            showAppGrid(); // Start at the home screen

            const appsGrid = document.getElementById('phone-apps-grid');
            if (appsGrid.children.length > 0) return; // Populate apps only once

            const apps = [
                { name: 'Favorites', icon: '⭐', panelId: 'favorites-panel', action: openFavoritesPanel },
                { name: 'Order', icon: '📦', panelId: 'restock-panel', action: openRestockPanel },
                { name: 'Basket', icon: '🧺', panelId: 'basket-panel', action: openBasketPanel },
                { name: 'Shelves', icon: '📚', panelId: 'shelf-assignment-panel', action: openShelfAssignmentPanel },
                { name: 'Employees', icon: '👥', panelId: 'employees-panel', action: openEmployeesPanel },
                { name: 'Customers', icon: '👤', panelId: 'customers-panel', action: openCustomersPanel },
                { name: 'Unlocks', icon: '🔑', panelId: 'unlocks-panel', action: openUnlocksPanel },
                { name: 'Reports', icon: '📈', panelId: 'reports-panel', action: () => showMessage("Daily reports coming soon!") },
                { name: 'Settings', icon: '⚙️', panelId: 'settings-panel', action: () => showAppScreen('settings-panel') },
            ];

            apps.forEach(app => {
                const appButton = document.createElement('button');
                appButton.className = 'flex flex-col items-center justify-center space-y-1 text-white hover:bg-gray-700 rounded-lg p-2 transition-colors';
                appButton.innerHTML = `
                    <div class="text-4xl">${app.icon}</div>
                    <span class="text-xs font-medium">${app.name}</span>
                `;
                appButton.onclick = () => {
                    // Prepare the panel's content first, then show it.
                    if(app.action) app.action();
                    // For simple panels without a dedicated open function, just show the screen.
                    else showAppScreen(app.panelId);
                };
                appsGrid.appendChild(appButton);
            });
        }

        function openFavoritesPanel() {
            const favoritesGrid = document.getElementById('favorites-grid');
            favoritesGrid.innerHTML = '';
            updateFavoritesTotal();

            if (starredItems.length === 0) {
                favoritesGrid.innerHTML = `<p class="text-center p-4">No items have been starred yet. Star items from the main order screen.</p>`;
                showAppScreen('favorites-panel');
                return;
            }

            favoritesGrid.innerHTML += `
                <div class="grid grid-cols-4 gap-2 border-b-2 border-amber-800/20 pb-2 text-lg font-handwritten">
                    <span class="font-bold col-span-2">Item</span>
                    <span class="text-right font-bold">Cost</span>
                    <span class="text-center font-bold">Order Qty</span>
                </div>
            `;

            for (const itemName of starredItems) {
                const itemData = items[itemName];
                const restockPrice = parseFloat((itemData.cost * 0.75).toFixed(2));
                const orderQty = currentFavoritesOrder[itemName] || 0;
                const itemDiv = document.createElement('div');
                itemDiv.className = 'grid grid-cols-4 gap-2 items-center py-2 border-b border-amber-800/10';
                itemDiv.innerHTML = `
                    <span class="text-lg col-span-2">${itemName}</span>
                    <span class="text-right text-lg">$${restockPrice.toFixed(2)}</span>
                    <div class="flex items-center justify-center space-x-2">
                        <span class="font-handwritten text-xl w-8 text-center">${orderQty}</span>
                        <button class="btn-style qty-btn-phone text-sm px-2 py-1" data-item="${itemName}" data-amount="5">+5</button>
                    </div>
                `;
                favoritesGrid.appendChild(itemDiv);
            }

            favoritesGrid.querySelectorAll('.qty-btn-phone').forEach(button => {
                button.addEventListener('click', (e) => {
                    const itemName = e.target.dataset.item;
                    const amount = parseInt(e.target.dataset.amount, 10);
                    currentFavoritesOrder[itemName] = (currentFavoritesOrder[itemName] || 0) + amount;
                    openFavoritesPanel(); // Re-open to refresh quantities
                });
            });

            showAppScreen('favorites-panel');
        }

        function updateFavoritesTotal() {
            let total = 0;
            for (const itemName in currentFavoritesOrder) {
                const quantity = currentFavoritesOrder[itemName];
                const itemData = items[itemName];
                const restockPrice = parseFloat((itemData.cost * 0.75).toFixed(2));
                total += restockPrice * quantity;
            }
            document.getElementById('favorites-total').textContent = total.toFixed(2);
        }

        function openRestockPanel() {
            const restockGrid = document.getElementById('restock-grid');
            restockGrid.innerHTML = '';
            // currentRestockOrder = {}; // Keep order state if panel is closed
            updateRestockTotal();

            // Determine which items are available to order based on unlocked storage
            const unlockedItems = new Set();
            storageCells.forEach((cell, index) => {
                if (unlocks.storage[index]) {
                    cell.allowedItems.forEach(item => unlockedItems.add(item));
                }
            });

            // Always allow ordering of items in the first (default unlocked) storage cell
            storageCells[0].allowedItems.forEach(item => unlockedItems.add(item));


            if (unlockedItems.size === 0) {
                restockGrid.innerHTML = `<p class="text-center p-4">Unlock more storage cells to order new types of items!</p>`;
                return;
            }

            restockGrid.innerHTML += `
                <div class="grid grid-cols-5 gap-2 border-b-2 border-amber-800/20 pb-2 text-lg font-handwritten">
                    <span class="text-center">⭐</span>
                    <span class="font-bold">Item</span>
                    <span class="text-right font-bold">Cost</span>
                    <span class="text-right font-bold">Stock</span>
                    <span class="text-center font-bold">Order Qty</span>
                </div>
            `;
            for (const itemName of unlockedItems) {
                const itemData = items[itemName];
                const restockPrice = parseFloat((itemData.cost * 0.75).toFixed(2));
                const isStarred = starredItems.includes(itemName);

                const itemDiv = document.createElement('div');
                itemDiv.className = 'grid grid-cols-5 gap-2 items-center py-2 border-b border-amber-800/10';
                itemDiv.innerHTML = `
                    <button class="text-2xl text-center star-btn" data-item="${itemName}">${isStarred ? '⭐' : '☆'}</button>
                    <span class="text-lg">${itemName}</span>
                    <span class="text-right text-lg">$${restockPrice.toFixed(2)}</span>
                    <span class="text-right text-lg">${inventory[itemName]}</span>
                    <div class="flex items-center justify-center space-x-1">
                        <input type="number" min="0" value="${currentRestockOrder[itemName] || 0}" data-item="${itemName}" class="w-16 p-1 text-center border-2 border-amber-800 rounded-md bg-white/80 focus:outline-none focus:ring-2 focus:ring-amber-600">
                        <button class="btn-style qty-btn text-sm px-2 py-1" data-item="${itemName}" data-amount="1">+1</button>
                        <button class="btn-style qty-btn text-sm px-2 py-1" data-item="${itemName}" data-amount="5">+5</button>
                    </div>
                `;
                restockGrid.appendChild(itemDiv);
            }

            // Add event listeners after all elements are in the DOM
            restockGrid.querySelectorAll('.star-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const itemName = e.target.dataset.item;
                    if (starredItems.includes(itemName)) {
                        starredItems = starredItems.filter(i => i !== itemName);
                        e.target.textContent = '☆';
                    } else {
                        if (starredItems.length < 5) {
                            starredItems.push(itemName);
                            e.target.textContent = '⭐';
                        } else {
                            showMessage("You can only star up to 5 items.");
                        }
                    }
                    saveGame();
                });
            });

            restockGrid.querySelectorAll('input[type="number"]').forEach(input => {
                input.addEventListener('input', (e) => {
                    const itemName = e.target.dataset.item;
                    let quantity = parseInt(e.target.value, 10);
                     if (isNaN(quantity) || quantity < 0) {
                        quantity = 0;
                        e.target.value = 0;
                    }

                    if (quantity > 0) {
                        currentRestockOrder[itemName] = quantity;
                    } else {
                        delete currentRestockOrder[itemName];
                    }
                    updateRestockTotal();
                });
            });

            restockGrid.querySelectorAll('.qty-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const itemName = e.target.dataset.item;
                    const amount = parseInt(e.target.dataset.amount, 10);
                    const input = restockGrid.querySelector(`input[data-item="${itemName}"]`);
                    let currentValue = parseInt(input.value, 10) || 0;
                    currentValue += amount;
                    input.value = currentValue;

                    // Manually trigger the input event to update the order
                    input.dispatchEvent(new Event('input'));
                });
            });

            showAppScreen('restock-panel');
        }

        function purchaseUnlock(type, key) {
            let cost = 0;
            let prerequisite = true;

            if (type === 'employee') {
                cost = unlockCosts.employees[key];
            } else if (type === 'shelf') {
                key = parseInt(key);
                cost = unlockCosts.shelves[key];
                if (key > 0 && !unlocks.shelves[key - 1]) {
                    prerequisite = false;
                }
            } else if (type === 'storage') {
                key = parseInt(key);
                cost = unlockCosts.storage[key];
                if (key > 0 && !unlocks.storage[key - 1]) {
                    prerequisite = false;
                }
            }

            if (developerMode) {
                cost = 0;
            }

            if (!prerequisite) {
                showMessage("You must unlock the previous tier first!");
                return;
            }

            if (shopPoints >= cost) {
                shopPoints -= cost;
                if (type === 'employee') {
                    unlocks.employees[key] = true;
                } else if (type === 'shelf') {
                    unlocks.shelves[key] = true;
                } else if (type === 'storage') {
                    unlocks.storage[key] = true;
                }

                spawnFloatingText('Unlocked!', player.x, player.y - 90, '#f59e0b');
                updateUI();
                saveGame();
                openUnlocksPanel(); // Refresh the panel
            } else {
                showMessage(`You need ${cost} points to unlock this.`);
            }
        }

        function openUnlocksPanel() {
            const empContainer = document.getElementById('unlocks-employees');
            const shelvesContainer = document.getElementById('unlocks-shelves');
            const storageContainer = document.getElementById('unlocks-storage');
            empContainer.innerHTML = '';
            shelvesContainer.innerHTML = '';
            storageContainer.innerHTML = '';

            // Employees
            for (const emp in unlockCosts.employees) {
                const cost = developerMode ? 0 : unlockCosts.employees[emp];
                const isUnlocked = unlocks.employees[emp];
                const canAfford = shopPoints >= cost;
                const div = document.createElement('div');
                div.className = 'flex items-center justify-between p-2 bg-white/50 rounded-md';
                div.innerHTML = `
                    <div>
                        <span class="text-lg">${emp.charAt(0).toUpperCase() + emp.slice(1)}</span>
                        <span class="text-sm text-amber-800/80 block">Cost: ${cost} Points</span>
                    </div>
                    <button class="btn-style px-4 py-1" data-type="employee" data-key="${emp}" ${isUnlocked ? 'disabled' : ''} ${!canAfford && !isUnlocked ? 'disabled' : ''}>
                        ${isUnlocked ? 'Unlocked' : 'Buy'}
                    </button>
                `;
                empContainer.appendChild(div);
            }

            // Shelves (starting from the second one)
            for (let i = 1; i < unlockCosts.shelves.length; i++) {
                const cost = developerMode ? 0 : unlockCosts.shelves[i];
                const isUnlocked = unlocks.shelves[i];
                const canAfford = shopPoints >= cost;
                const prerequisiteMet = unlocks.shelves[i - 1];
                const div = document.createElement('div');
                div.className = 'flex items-center justify-between p-2 bg-white/50 rounded-md';
                div.innerHTML = `
                    <div>
                        <span class="text-lg">Shelf ${i + 1}</span>
                        <span class="text-sm text-amber-800/80 block">Cost: ${cost} Points</span>
                    </div>
                    <button class="btn-style px-4 py-1" data-type="shelf" data-key="${i}" ${isUnlocked || !prerequisiteMet ? 'disabled' : ''} ${!canAfford && !isUnlocked ? 'disabled' : ''}>
                        ${isUnlocked ? 'Unlocked' : (prerequisiteMet ? 'Buy' : 'Locked')}
                    </button>
                `;
                shelvesContainer.appendChild(div);
            }

            // Storage
            for (let i = 0; i < unlockCosts.storage.length; i++) {
                const cost = developerMode ? 0 : unlockCosts.storage[i];
                const isUnlocked = unlocks.storage[i];
                const canAfford = shopPoints >= cost;
                const prerequisiteMet = i === 0 || unlocks.storage[i - 1];
                const div = document.createElement('div');
                div.className = 'flex items-center justify-between p-2 bg-white/50 rounded-md';
                div.innerHTML = `
                    <div>
                        <span class="text-lg">${storageCells[i].label} Storage</span>
                        <span class="text-sm text-amber-800/80 block">Cost: ${cost} Points</span>
                    </div>
                    <button class="btn-style px-4 py-1" data-type="storage" data-key="${i}" ${isUnlocked || !prerequisiteMet ? 'disabled' : ''} ${!canAfford && !isUnlocked ? 'disabled' : ''}>
                        ${isUnlocked ? 'Unlocked' : (prerequisiteMet ? 'Buy' : 'Locked')}
                    </button>
                `;
                storageContainer.appendChild(div);
            }

            document.getElementById('unlocks-panel').querySelectorAll('button[data-type]').forEach(button => {
                button.addEventListener('click', (e) => {
                    const type = e.currentTarget.dataset.type;
                    const key = e.currentTarget.dataset.key;
                    purchaseUnlock(type, key);
                });
            });

            showAppScreen('unlocks-panel');
        }


        function updateRestockTotal() {
            let total = 0;
            for (const itemName in currentRestockOrder) {
                const quantity = currentRestockOrder[itemName];
                const itemData = items[itemName];
                const restockPrice = parseFloat((itemData.cost * 0.75).toFixed(2));
                total += restockPrice * quantity;
            }
            document.getElementById('restock-total').textContent = total.toFixed(2);
        }

        function placeOrder(isPhoneOrder = false) {
            const orderSource = isPhoneOrder ? currentFavoritesOrder : currentRestockOrder;
            const panelId = isPhoneOrder ? 'favorites' : 'restock';
            const MAX_DOCK_PACKAGES = 5;

            let totalCost = 0;
            let itemsToOrder = 0;
            let packagesFromOrder = 0;

            for (const itemName in orderSource) {
                const quantity = orderSource[itemName];
                if (quantity > 0) {
                    const itemData = items[itemName];
                    const restockPrice = parseFloat((itemData.cost * 0.75).toFixed(2));
                    totalCost += restockPrice * quantity;
                    itemsToOrder++;
                    packagesFromOrder += Math.ceil(quantity / MAX_PACKAGE_SIZE);
                }
            }

            if (itemsToOrder === 0) {
                showMessage("Your order is empty.");
                return;
            }

            if (loadingDockPackages.length + packagesFromOrder > MAX_DOCK_PACKAGES) {
                showMessage(`This order would create ${packagesFromOrder} packages, exceeding the loading dock limit of ${MAX_DOCK_PACKAGES}. Please clear some space first.`);
                return;
            }


            if (cash >= totalCost) {
                cash -= totalCost;
                for (const itemName in orderSource) {
                    let quantityToOrder = orderSource[itemName];
                    while (quantityToOrder > 0) {
                        const quantityForPackage = Math.min(quantityToOrder, MAX_PACKAGE_SIZE);
                        loadingDockPackages.push({itemName: itemName, quantity: quantityForPackage});
                        quantityToOrder -= quantityForPackage;
                    }
                }
                if (isPhoneOrder) {
                currentFavoritesOrder = {};
                } else {
                    currentRestockOrder = {};
                }
                updateUI();
                saveGame();
                closePhone();
                showMessage(`Order placed for $${totalCost.toFixed(2)}! The supplies have been delivered to the loading dock.`);
            } else {
                showMessage(`You can't afford this order! You need $${totalCost.toFixed(2)} but only have $${cash.toFixed(2)}.`);
            }
        }

        function openStorageCell(cell) {
            activeStorageCell = cell;
            const storageGrid = document.getElementById('storage-grid');
            document.getElementById('storage-title').textContent = cell.label;
            storageGrid.innerHTML = '';
            if (cell.allowedItems.length === 0) {
                storageGrid.innerHTML = `<p class="col-span-4 text-center">No items are stored here.</p>`;
            }
            cell.allowedItems.forEach(itemName => {
                const itemDiv = document.createElement('div');
                itemDiv.className = `p-2 text-center border-2 border-amber-900 rounded-lg bg-white shadow-sm`;
                const inStock = cell.items[itemName] > 0;
                const canPutBack = player.basket.includes(itemName);
                itemDiv.innerHTML = `
                    <div class="font-handwritten text-xl">${itemName}</div>
                    <div class="text-xs">In Stock: ${cell.items[itemName] || 0}</div>
                    <div class="mt-2 flex justify-center space-x-2">
                        <button class="btn-style px-3 py-1 text-sm" data-action="take" data-item="${itemName}" ${!inStock || player.basket.length >= MAX_BASKET_SIZE ? 'disabled' : ''}>Take 1</button>
                        <button class="btn-style px-3 py-1 text-sm" data-action="put_back" data-item="${itemName}" ${!canPutBack ? 'disabled' : ''}>Put Back 1</button>
                    </div>
                `;
                storageGrid.appendChild(itemDiv);
            });
            storageGrid.querySelectorAll('button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const action = e.target.dataset.action;
                    const itemName = e.target.dataset.item;
                    if (action === 'take') {
                        takeItemFromStorage(itemName, cell);
                    } else if (action === 'put_back') {
                        putItemInStorage(itemName, cell);
                    }
                });
            });
            showAppScreen('storage-panel');
        }

function openProductAssignmentForShelf(shelf, slotIndex) {
            const assignmentGrid = document.getElementById('assignment-grid');
            const assignmentTitle = document.getElementById('assignment-title');
            assignmentGrid.innerHTML = '';
            assignmentTitle.textContent = `Assign to Shelf ${shelves.indexOf(shelf) + 1} - Slot ${slotIndex + 1}`;

            const currentSlot = shelf.items[slotIndex];

            const backButton = document.createElement('button');
            backButton.className = 'btn-style bg-amber-700/80 hover:bg-amber-600';
            backButton.textContent = '← Back';
            backButton.onclick = () => showShelfSlotsForAssignment(shelf);
            assignmentGrid.appendChild(backButton);

            const clearButton = document.createElement('button');
            clearButton.className = 'btn-style bg-red-700/80 hover:bg-red-600';
            clearButton.textContent = 'Clear';
            clearButton.onclick = () => {
                const itemToMove = currentSlot.assignedItem;
                const quantityToMove = currentSlot.quantity;

                if (quantityToMove > 0 && itemToMove) {
                    const storageCell = storageCells.find(c => c.allowedItems.includes(itemToMove));
                    if (!storageCell) {
                        showMessage(`Error: No storage cell for ${itemToMove}. Cannot move items.`);
                        return;
                    }
                    const currentFill = Object.values(storageCell.items).reduce((a, b) => a + b, 0);
                    if (currentFill + quantityToMove > storageCell.capacity) {
                        showMessage(`Not enough room in ${storageCell.label} storage to move ${quantityToMove} items.`);
                        return;
                    }
                    storageCell.items[itemToMove] = (storageCell.items[itemToMove] || 0) + quantityToMove;
                }

                currentSlot.assignedItem = null;
                currentSlot.quantity = 0;
                saveGame();
                togglePanel('assignment', false);
                togglePanel('shelf-assignment', true);
                showShelfSlotsForAssignment(shelf);
            };
            assignmentGrid.appendChild(clearButton);

            for (const itemName in items) {
                const button = document.createElement('button');
                button.className = 'btn-style';
                button.textContent = itemName;
                button.dataset.item = itemName;
                button.onclick = () => {
                    const oldItem = currentSlot.assignedItem;
                    const oldQuantity = currentSlot.quantity;
                    const newItem = itemName;

                    if (oldItem === newItem) {
                        togglePanel('assignment', false);
                        return;
                    }

                    if (oldQuantity > 0 && oldItem) {
                        const storageCell = storageCells.find(c => c.allowedItems.includes(oldItem));
                        if (!storageCell) {
                            showMessage(`Error: No storage cell for ${oldItem}. Cannot move items.`);
                            return;
                        }
                        const currentFill = Object.values(storageCell.items).reduce((a, b) => a + b, 0);
                        if (currentFill + oldQuantity > storageCell.capacity) {
                            showMessage(`Not enough room in ${storageCell.label} storage to move ${oldQuantity} ${oldItem}.`);
                            return;
                        }
                        storageCell.items[oldItem] = (storageCell.items[oldItem] || 0) + oldQuantity;
                        currentSlot.quantity = 0;
                    }

                    currentSlot.assignedItem = newItem;
                    saveGame();
                    togglePanel('assignment', false);
                    togglePanel('shelf-assignment', true);
                    showShelfSlotsForAssignment(shelf);
                };
                assignmentGrid.appendChild(button);
            }
            showAppScreen('assignment-panel');
        }

        function openShelfPanel(shelf) {
            activeShelf = shelf;
            const shelfGrid = document.getElementById('shelf-grid');
            shelfGrid.innerHTML = '';
            for (let i = 0; i < 4; i++) {
                const slot = shelf.items[i];
                const slotDiv = document.createElement('div');
                slotDiv.className = 'p-2 text-center border-2 border-dashed border-amber-700 rounded-lg flex flex-col justify-between min-h-[100px]';
                let content = '';

                if (slot.assignedItem) {
                    const canPlaceMore = player.basket.includes(slot.assignedItem) && slot.quantity < MAX_SHELF_STACK;
                    const canTake = slot.quantity > 0 && player.basket.length < MAX_BASKET_SIZE;
                    content = `
                        <div>
                            <div class="font-handwritten text-lg">${slot.assignedItem}</div>
                            <div>${slot.quantity} / ${MAX_SHELF_STACK}</div>
                        </div>
                        <div class="mt-2 flex justify-center space-x-2">
                            <button class="btn-style px-2 py-1 text-sm" data-action="take" data-shelf="${shelves.indexOf(shelf)}" data-slot="${i}" ${!canTake ? 'disabled' : ''}>Take</button>
                            <button class="btn-style px-2 py-1 text-sm" data-action="place" data-shelf="${shelves.indexOf(shelf)}" data-slot="${i}" ${!canPlaceMore ? 'disabled' : ''}>Place</button>
                        </div>
                    `;
                } else {
                    content = `<div class="self-center">Empty Slot</div>`;
                }
                slotDiv.innerHTML = content;
                shelfGrid.appendChild(slotDiv);
            }

            shelfGrid.querySelectorAll('button').forEach(button => {
                button.addEventListener('click', e => {
                    const shelfIndex = parseInt(e.target.dataset.shelf, 10);
                    const slotIndex = parseInt(e.target.dataset.slot, 10);
                    const action = e.target.dataset.action;
                    const targetShelf = shelves[shelfIndex];
                    const targetSlot = targetShelf.items[slotIndex];
                    if (action === 'take') {
                        player.basket.push(targetSlot.assignedItem);
                        targetSlot.quantity--;
                    } else if (action === 'place') {
                        const itemIndex = player.basket.indexOf(targetSlot.assignedItem);
                        if (itemIndex > -1) {
                            player.basket.splice(itemIndex, 1);
                            targetSlot.quantity++;
                        }
                    }
                    saveGame();
                    openShelfPanel(targetShelf); // Refresh panel
                });
            });

            showAppScreen('shelf-panel');
        }

        function takeItemFromStorage(itemName, cell) {
            if (player.basket.length < MAX_BASKET_SIZE) {
                if (cell.items[itemName] > 0) {
                    cell.items[itemName]--;
                    player.basket.push(itemName);
                    saveGame();
                    openStorageCell(cell); // Refresh panel
                }
            } else {
                showMessage("Your basket is full!");
            }
        }

        function putItemInStorage(itemName, cell) {
            const itemIndex = player.basket.indexOf(itemName);
            if (itemIndex > -1) {
                player.basket.splice(itemIndex, 1);
                if (!cell.items[itemName]) cell.items[itemName] = 0;
                cell.items[itemName]++;
                saveGame();
                openStorageCell(cell); // Refresh panel
            }
        }


        let activePanel = null; // DEPRECATED: Will be replaced by phone-specific logic
        let activePhoneScreen = null; // Tracks the currently open app screen inside the phone
        let isPhoneOpen = false;
        let activeShelf = null;
        let activeStorageCell = null;

        function closePhone() {
            const phonePanel = document.getElementById('phone-panel');
            phonePanel.classList.add('hidden');
            isPhoneOpen = false;
            activePhoneScreen = null;
        }

        function showAppGrid() {
            document.getElementById('phone-apps-grid').classList.remove('hidden');
            document.getElementById('phone-app-screens').classList.add('hidden');
            activePhoneScreen = null;
        }

        function showAppScreen(panelId) {
            const appScreensContainer = document.getElementById('phone-app-screens');

            // Hide all other screens within the container
            const allScreens = appScreensContainer.querySelectorAll('.phone-app-screen');
            allScreens.forEach(screen => screen.classList.add('hidden'));

            // Show the target screen
            const targetScreen = document.getElementById(panelId);
            if (targetScreen) {
                targetScreen.classList.remove('hidden');
            }

            // Show the container and hide the grid
            appScreensContainer.classList.remove('hidden');
            document.getElementById('phone-apps-grid').classList.add('hidden');

            activePhoneScreen = panelId;
        }


        function togglePanel(panelName, forceOpen = false) {
            // This function is now a legacy wrapper. New UI should use the phone functions.
            const targetPanel = document.getElementById(`${panelName}-panel`);
            if (forceOpen) {
                 if (targetPanel) targetPanel.classList.remove('hidden');
                 activePanel = panelName;
            } else {
                 if (targetPanel) targetPanel.classList.add('hidden');
                 activePanel = null;
            }
             if (panelName === 'shelf') activeShelf = null;
             if (panelName === 'storage') activeStorageCell = null;
        }

        function startNewGame() {
            if (confirm("Are you sure you want to start a new game? All your progress will be lost.")) {
                localStorage.removeItem('artEmporiumSave');
                window.location.reload();
            }
        }

        function saveGame() {
            const gameState = {
                cash, day, shopPoints, itemPopularity,
                inventory, storageCells, shelves,
                unlocks, loadingDockPackages, customerDemand,
                customerProfiles, starredItems
            };
            localStorage.setItem('artEmporiumSave', JSON.stringify(gameState));
        }

        function loadGame() {
            const savedState = localStorage.getItem('artEmporiumSave');
            if (savedState) {
                try {
                    const gameState = JSON.parse(savedState);
                    cash = gameState.cash || 100;
                    day = gameState.day || 1;
                    shopPoints = gameState.shopPoints || 0;
                    itemPopularity = gameState.itemPopularity || {};
                    inventory = gameState.inventory || inventory;
                    storageCells = gameState.storageCells || storageCells;
                    shelves = gameState.shelves || shelves;
                    unlocks = gameState.unlocks || unlocks;
                    loadingDockPackages = gameState.loadingDockPackages || [];
                    customerDemand = gameState.customerDemand || {};
                    starredItems = gameState.starredItems || [];

                    // Initialize popularity for any items missing from save
                    Object.keys(items).forEach(item => {
                        if (!itemPopularity[item]) {
                            itemPopularity[item] = 0;
                        }
                    });

                    if (gameState.customerProfiles) {
                        // Deep merge saved profiles into the default ones
                        for (const type in gameState.customerProfiles) {
                            if (customerProfiles[type]) {
                                for (const name in gameState.customerProfiles[type]) {
                                    if (customerProfiles[type][name]) {
                                        Object.assign(customerProfiles[type][name], gameState.customerProfiles[type][name]);
                                    }
                                }
                            }
                        }
                    }


                    // Re-attach draw methods to shelves as they are lost in JSON.
                    shelves.forEach(shelf => {
                         shelf.draw = drawShelf; // REFACTOR: Assign the single draw function
                    });

                } catch (e) {
                    console.error("Failed to parse saved game data:", e);
                    localStorage.removeItem('artEmporiumSave'); // Clear corrupted save
                }
            }
        }

        function init() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            pieClockCanvas = document.getElementById('pie-clock-canvas');
            pieClockCtx = pieClockCanvas.getContext('2d');

            loadGame(); // Load game state before resizing/initializing layout
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            canvas.addEventListener('click', handleCanvasClick);
            pieClockCanvas.addEventListener('click', handleClockClick);

            document.getElementById('start-day-btn').addEventListener('click', () => {
                if(dayStarted) return;
                dayStarted = true;
                dayTimer = DAY_DURATION;
                timeSinceLastCustomer = 0;
                document.getElementById('start-day-btn').classList.add('hidden');
                document.getElementById('next-day-btn').classList.remove('hidden');
                // Ensure all idle states are correct before starting
                if (!stocker.task) stocker.state = 'idle';
                if (!cashier.task) cashier.state = 'idle';
                if (!loader.task) loader.state = 'idle';
                if (!manager.task) manager.state = 'idle';
                if (!salesperson.task) salesperson.state = 'idle';
            });


            document.getElementById('place-order-btn').addEventListener('click', () => placeOrder(false));
            document.getElementById('place-favorites-order-btn').addEventListener('click', () => placeOrder(true));
            document.getElementById('new-game-btn').addEventListener('click', startNewGame);

            // Phone Navigation
            document.getElementById('close-phone').addEventListener('click', closePhone);
            document.getElementById('phone-back-btn').addEventListener('click', showAppGrid);

            // Settings Toggles
            const devToggle = document.getElementById('developer-toggle');
            devToggle.checked = developerMode;
            devToggle.addEventListener('change', (e) => {
                developerMode = e.target.checked;
                updateUI();
            });
            const continuousToggle = document.getElementById('continuous-toggle');
            continuousToggle.checked = continuousMode;
            continuousToggle.addEventListener('change', (e) => {
                continuousMode = e.target.checked;
            });

            loadSpriteSheet(); // Generate and load player spritesheet
            updateUI();
            requestAnimationFrame(gameLoop);
            document.getElementById('start-day-btn').click();
        }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>